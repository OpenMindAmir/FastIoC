{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FastIoC","text":"<p>IoC/DI container for FastAPI with automatic type-based dependency injection</p> <p> </p>"},{"location":"#why-fastioc","title":"Why FastIoC \ud83e\udd14","text":"<p>FastIoC bridges the gap between Python\u2019s dynamic nature and modern dependency injection patterns found in frameworks like .NET, Laravel, Spring Boot, and NestJS \u2014 with zero boilerplate and full FastAPI compatibility. It\u2019s designed to make implementing scalable architectural patterns such as Clean Architecture or Hexagonal Architecture effortless and intuitive.</p> <p>Features:</p> <ul> <li> <p>\ud83e\uddf9 Write cleaner, loosely coupled code while staying true to the \u26d3\ufe0f\u200d\ud83d\udca5 Dependency Inversion Principle (SOLID - D) \u2014 with ABSOLUTELY ZERO boilerplate! \u26a1</p> </li> <li> <p>\u2699\ufe0f Enjoy hassle-free, automatic nested dependency resolution using Python type hints with flexible lifetimes: \u267b\ufe0f Singleton, \ud83e\uddfa Scoped, and \u2668\ufe0f Transient (inspired by .NET)</p> </li> <li> <p>\ud83d\ude80 Zero runtime overhead \u2014 everything is resolved at startup!</p> </li> <li> <p>\ud83e\udd1d 100% compatible &amp; based on FastAPI\u2019s native dependency injection \u2014 no black boxes, no magic \ud83e\ude84</p> </li> <li> <p>\u267b\ufe0f Singleton support with automatic cleanup on application shutdown \ud83e\uddf9</p> </li> <li> <p>\ud83e\uddea Full support for FastAPI's <code>dependency_overrides</code> using type annotations \u2014 even with mock containers \ud83d\udc89</p> </li> <li> <p>\ud83d\udce6 Comes with the amazing <code>APIController</code> \u2014 the best class-based view (CBV) system ever seen in Python \ud83c\udfc6</p> </li> <li> <p>\ud83d\udd27 Comes with customizable hooks, detailed logs &amp; ... \ud83d\udcca</p> </li> </ul>"},{"location":"#sponsors","title":"Sponsors \ud83d\udc9d","text":"<p>You can   us on a regular basis to become a sponsor. For more info, contact OpenMindAmir@gmail.com.</p>"},{"location":"#installation","title":"Installation \ud83d\udce5","text":"<pre><code>$ pip install fastioc\n</code></pre>"},{"location":"#usage","title":"Usage \ud83d\udca1","text":"<p>Sample interface &amp; implementation:</p> <pre><code>from typing import Protocol\n\n# Define the interfaces \ud83d\udcdc\n\nclass INumberGenerator(protocol):\n\n    def generate(self) -&gt; int: ...\n\n\nclass IService(Protocol):\n\n    def get_number(self) -&gt; int: ...\n\n\n# Implement concrete classes (Actual dependencies) \ud83c\udfd7\ufe0f\n\nclass SimpleNumberGenerator(INumberGenerator):\n\n    def generate(self) -&gt; int:\n        return 42\n\nclass ExampleService(IService):\n\n    number_service: INumberGenerator # Nested dependency with type hints! \u26a1\n\n    def get_number(self) -&gt; int:\n        return self.number_service.generate()\n</code></pre> <p>Create container, register dependencies &amp; use them in endpoints!</p> <pre><code>from fastapi import FastAPI\n\nfrom fastioc import Container # Import the Container\n\n\n# Create container and register dependency \ud83d\udcdd\ncontainer = Container()\ncontainer.add_scoped(INumberGenerator, SimpleNumberGenetator)\ncontainer.add_scoped(IService, ExampleService) # Also available: add_singleton, add_transient\n\n\n# Create FastAPI app and integrate it with the container \ud83e\ude84\napp = FastAPI()\ncontainer.injectify(app)\n\n\n# Now your endpoints are injectified! \ud83c\udf89\n@app.get('/')\ndef index(service: IService) -&gt; int: # Only use the interface - no 'Depends' needed\n    return service.get_number() # 42 \ud83e\udd29\n</code></pre>"},{"location":"#apicontroller","title":"APIController \ud83d\udce6","text":"<pre><code>from fastapi import FastAPI\n\nfrom fastioc import Container\nfrom fastioc.controller import APIController, get, post\n\n# Create container &amp; register dependencies \ud83d\udcdd\ncontainer = Container()\ncontainer.add_scoped(IService, ExampleService)\n\n# Define an example controller\nclass ExampleController(APIController):\n    config = { # APIRouter parameters (+ IDE Autocomplete \ud83e\udd29)\n        \"prefix\": '/example',\n        \"tag\": 'example',\n        \"container\": container # ! DO NOT FORGET\n    }\n\n    service: IService # Available in all endpoints! \u26a1\n\n    @get('/read')\n    def read_example(self) -&gt; int:\n        return self.service.get_number()\n\n    @post('/set')\n    def set_example(self) -&gt; bool:\n        # ...\n        return True\n\napp = FastAPI()\napp.include_router(ExampleController.router()) # Get router from controller and include it\n</code></pre> <ul> <li>APIController endpoints are injectified so you can also resolve dependencies in each endpoint separately.</li> <li>You can also resolve dependencies in <code>__init__</code> of your controller.</li> <li>Read more in the APIController documentation</li> </ul>"},{"location":"#learn-more","title":"Learn More \ud83d\udcd8","text":"<p>Check out the full documentation for advanced examples, architecture guides, best practices, and more.</p>"},{"location":"#contributing","title":"Contributing \ud83d\udcac","text":"<p>Got an idea, found a bug, or want to improve FastIoC? Feel free to open an issue or submit a pull request \u2014 contributions are always welcome \ud83e\udd1d</p>"},{"location":"#license","title":"License \u2696\ufe0f","text":"<p>This project is licensed under the MIT License \u2014 see the LICENSE file for details.</p>"},{"location":"LICENSE/","title":"LICENSE","text":"<p>MIT License</p> <p>Copyright (c) 2025 Amir R. Aliakbari (OpenMindAmir@gmail.com)</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"controller/","title":"APIController","text":"<p>The <code>APIController</code> is FastIoC's powerful class-based view system that brings modern controller patterns to FastAPI. It allows you to organize related endpoints into classes with shared attributes, variables, methods, and dependencies making your code more maintainable and easier to scale.</p>"},{"location":"controller/#why-use-apicontroller","title":"Why Use APIController?","text":"<p>Traditional FastAPI function-based views work great for simple APIs, but as your application grows, you'll find yourself: - Repeating dependency injections across multiple related endpoints - Creating helper functions that need access to the same services - Struggling to organize related endpoint logic - Missing the benefits of class-based organization</p> <p><code>APIController</code> solves these problems by letting you: - Share dependencies across all endpoints in the controller - Group related endpoints in a single, organized class - Reuse methods and attributes across multiple routes - Keep your code DRY by avoiding repetition</p>"},{"location":"controller/#importing-apicontroller","title":"Importing APIController","text":"<pre><code>from fastioc.controller import (\n    APIController,  # Base controller class\n    # HTTP method decorators (same as FastAPI)\n    get,\n    post,\n    put,\n    patch,\n    delete,\n    head,\n    options,\n    trace,\n    websocket\n)\n</code></pre> <p>All HTTP method decorators work exactly like their FastAPI counterparts (<code>@app.get</code>, <code>@app.post</code>, etc.), but are designed for use in controllers.</p>"},{"location":"controller/#basic-usage","title":"Basic Usage","text":""},{"location":"controller/#minimal-controller","title":"Minimal Controller","text":"<p>Here's the simplest possible controller:</p> <pre><code>from fastapi import FastAPI\nfrom fastioc.controller import APIController, get\n\nclass HealthController(APIController):\n    config = {\n        'prefix': '/health'\n    }\n\n    @get('/')\n    def check_health(self):\n        return {\"status\": \"healthy\"}\n\n# Create FastAPI app and include the controller\napp = FastAPI()\napp.include_router(HealthController.router())  # Call .router() class method\n</code></pre> <p>Important: Use <code>HealthController.router()</code> (class method), not <code>HealthController().router()</code> (instance method). Don't create instances yourself FastAPI handles that internally.</p>"},{"location":"controller/#configuration-with-ide-support","title":"Configuration with IDE Support","text":"<p>The <code>config</code> dictionary contains all <code>APIRouter</code> parameters plus the FastIoC container. It provides full IDE autocomplete and type hints:</p> <pre><code>from fastioc import Container\nfrom fastioc.controller import APIController, get\n\ncontainer = Container()\n# Register your dependencies...\n\nclass UserController(APIController):\n    config = {\n        'prefix': '/users',                    # Router prefix\n        'tags': ['Users'],                     # OpenAPI tags\n        'container': container,                # FastIoC container (required for DI)\n        'dependencies': [IAuthService],        # Shared dependencies for all routes\n        'deprecated': False,                   # Mark all routes as deprecated\n        'include_in_schema': True,             # Include in OpenAPI schema\n        # ... all other APIRouter parameters are supported\n    }\n\n    @get('/')\n    def list_users(self):\n        return {\"users\": []}\n</code></pre> <p>All <code>APIRouter</code> parameters are supported, including: - <code>prefix</code>, <code>tags</code>, <code>dependencies</code>, <code>responses</code> - <code>callbacks</code>, <code>routes</code>, <code>redirect_slashes</code> - <code>default_response_class</code>, <code>route_class</code> - <code>on_startup</code>, <code>on_shutdown</code>, <code>lifespan</code> - <code>include_in_schema</code>, <code>deprecated</code> - <code>generate_unique_id_function</code> - And more...</p> <p>For type hints, import the <code>APIRouterParams</code> type:</p> <pre><code>from fastioc.controller.definitions import APIRouterParams\n\nconfig: APIRouterParams = {\n    'prefix': '/api',\n    'container': container\n}\n</code></pre>"},{"location":"controller/#using-dependency-injection","title":"Using Dependency Injection","text":""},{"location":"controller/#with-container","title":"With Container","text":"<p>To use FastIoC's dependency injection, you must pass your container in the config:</p> <pre><code>from fastioc import Container\nfrom fastioc.controller import APIController, get, post\n\n# Setup container\ncontainer = Container()\ncontainer.add_scoped(IUserService, UserService)\ncontainer.add_scoped(IEmailService, EmailService)\n\nclass UserController(APIController):\n    config = {\n        'prefix': '/users',\n        'container': container  # Required for DI\n    }\n\n    @get('/{user_id}')\n    def get_user(self, user_id: int, service: IUserService):\n        # service is automatically injected\n        return service.get_user(user_id)\n\n    @post('/')\n    def create_user(self, user: UserCreate, service: IUserService):\n        return service.create_user(user)\n</code></pre>"},{"location":"controller/#without-container","title":"Without Container","text":"<p>If you don't need dependency injection, simply omit the container:</p> <pre><code>class SimpleController(APIController):\n    config = {\n        'prefix': '/simple'\n        # No container needed\n    }\n\n    @get('/')\n    def hello(self):\n        return {\"message\": \"Hello World\"}\n</code></pre>"},{"location":"controller/#shared-dependencies-and-data","title":"Shared Dependencies and Data","text":"<p>One of the most powerful features of <code>APIController</code> is the ability to share dependencies, data, and methods across all endpoints.</p>"},{"location":"controller/#shared-dependencies-via-class-type-hints","title":"Shared Dependencies via Class Type Hints","text":"<p>Use class-level type hints to inject dependencies that are available in all endpoints:</p> <pre><code>class ProductController(APIController):\n    config = {\n        'prefix': '/products',\n        'container': container\n    }\n\n    # Shared dependencies - available in ALL endpoints\n    db: IDatabaseService\n    cache: ICacheService\n    logger: ILoggerService\n\n    @get('/')\n    def list_products(self):\n        # Access shared dependencies via self\n        self.logger.log(\"Listing products\")\n        products = self.db.query(\"SELECT * FROM products\")\n        return {\"products\": products}\n\n    @get('/{product_id}')\n    def get_product(self, product_id: int):\n        # Same dependencies available here\n        cached = self.cache.get(f\"product:{product_id}\")\n        if cached:\n            return cached\n\n        product = self.db.query(f\"SELECT * FROM products WHERE id = {product_id}\")\n        self.cache.set(f\"product:{product_id}\", product)\n        return {\"product\": product}\n</code></pre>"},{"location":"controller/#shared-data-from-fastapi-request-data","title":"Shared Data from FastAPI (Request Data)","text":"<p>You can also share request data (query params, headers, etc.) across endpoints. See Passing Data to Dependencies - Pattern 1 for full details.</p> <p>In Class Type Hints, you must use <code>Annotated</code> with FastAPI's parameter types:</p> <pre><code>from fastapi import Query, Header\nfrom typing import Annotated\n\nclass ApiController(APIController):\n    config = {\n        'prefix': '/api',\n        'container': container\n    }\n\n    # \u2705 CORRECT: Use Annotated for request data in class hints\n    api_key: Annotated[str, Header()]\n    page: Annotated[int, Query(default=1)]\n\n    # L WRONG: Simple types don't work\n    # api_key: str  # Won't receive header!\n\n    # \u2705 FastIoC dependencies work as usual\n    service: IApiService\n\n    @get('/data')\n    def get_data(self):\n        # api_key and page are available\n        self.service.authenticate(self.api_key)\n        return self.service.fetch_data(page=self.page)\n</code></pre> <p>In <code>__init__</code> Parameters, FastAPI parameters work normally (no <code>Annotated</code> needed):</p> <pre><code>from fastapi import Query, Header, Depends\nfrom typing import Annotated\n\ndef get_auth_token(authorization: str = Header()) -&gt; str:\n    return authorization.replace(\"Bearer \", \"\")\n\nclass AuthController(APIController):\n    config = {\n        'prefix': '/auth',\n        'container': container\n    }\n\n    # Receive data in __init__ - works like normal FastAPI\n    def __init__(\n        self,\n        user_id: int = Query(),\n        token: Annotated[str, Depends(get_auth_token)] = None,\n        service: IAuthService = None  # From container\n    ):\n        self.user_id = user_id\n        self.token = token\n        self.service = service\n\n    @get('/profile')\n    def get_profile(self):\n        return self.service.get_user_profile(self.user_id, self.token)\n</code></pre> <p>See Nested Dependencies - Class Type Hints for more details.</p>"},{"location":"controller/#shared-methods","title":"Shared Methods","text":"<p>You can define helper methods that all endpoints can use:</p> <pre><code>class OrderController(APIController):\n    config = {\n        'prefix': '/orders',\n        'container': container\n    }\n\n    db: IDatabaseService\n    logger: ILoggerService\n\n    def _log_action(self, action: str, order_id: int):\n        \"\"\"Helper method shared by all endpoints\"\"\"\n        self.logger.log(f\"{action} order {order_id}\")\n\n    def _validate_order(self, order_id: int) -&gt; bool:\n        \"\"\"Another helper method\"\"\"\n        return self.db.exists(\"orders\", order_id)\n\n    @get('/{order_id}')\n    def get_order(self, order_id: int):\n        self._log_action(\"GET\", order_id)\n        if not self._validate_order(order_id):\n            raise HTTPException(404, \"Order not found\")\n        return self.db.query(f\"SELECT * FROM orders WHERE id = {order_id}\")\n\n    @delete('/{order_id}')\n    def delete_order(self, order_id: int):\n        self._log_action(\"DELETE\", order_id)\n        if not self._validate_order(order_id):\n            raise HTTPException(404, \"Order not found\")\n        self.db.execute(f\"DELETE FROM orders WHERE id = {order_id}\")\n        return {\"status\": \"deleted\"}\n</code></pre>"},{"location":"controller/#complete-example","title":"Complete Example","text":"<p>Here's a comprehensive example showing all features together:</p> <pre><code>from fastapi import FastAPI, Query, Header, HTTPException\nfrom fastioc import Container\nfrom fastioc.controller import APIController, get, post, put, delete\nfrom typing import Annotated\n\n# Setup container\ncontainer = Container()\ncontainer.add_scoped(IUserService, UserService)\ncontainer.add_scoped(IAuthService, AuthService)\ncontainer.add_scoped(ILoggerService, LoggerService)\n\n# Define controller\nclass UserController(APIController):\n    config = {\n        'prefix': '/users',\n        'tags': ['Users'],\n        'container': container,\n        'dependencies': [IAuthService]  # Runs on all routes\n    }\n\n    # Shared dependencies via class hints\n    service: IUserService\n    logger: ILoggerService\n\n    # Shared request data via class hints (must use Annotated)\n    api_version: Annotated[str, Header(alias=\"X-API-Version\", default=\"1.0\")]\n\n    # Receive data in __init__\n    def __init__(\n        self,\n        page_size: int = Query(10, ge=1, le=100)\n    ):\n        self.page_size = page_size\n\n    # Helper method\n    def _log(self, message: str):\n        self.logger.log(f\"[v{self.api_version}] {message}\")\n\n    @get('/')\n    def list_users(self, page: int = Query(1, ge=1)):\n        self._log(f\"Listing users - page {page}\")\n        users = self.service.get_users(\n            skip=(page - 1) * self.page_size,\n            limit=self.page_size\n        )\n        return {\"users\": users, \"page\": page}\n\n    @get('/{user_id}')\n    def get_user(self, user_id: int):\n        self._log(f\"Getting user {user_id}\")\n        user = self.service.get_user(user_id)\n        if not user:\n            raise HTTPException(404, \"User not found\")\n        return {\"user\": user}\n\n    @post('/')\n    def create_user(self, user: UserCreate):\n        self._log(f\"Creating user: {user.email}\")\n        new_user = self.service.create_user(user)\n        return {\"user\": new_user, \"created\": True}\n\n    @put('/{user_id}')\n    def update_user(self, user_id: int, user: UserUpdate):\n        self._log(f\"Updating user {user_id}\")\n        updated = self.service.update_user(user_id, user)\n        return {\"user\": updated}\n\n    @delete('/{user_id}')\n    def delete_user(self, user_id: int):\n        self._log(f\"Deleting user {user_id}\")\n        self.service.delete_user(user_id)\n        return {\"status\": \"deleted\", \"user_id\": user_id}\n\n# Include in FastAPI app\napp = FastAPI()\napp.include_router(UserController.router())\n</code></pre>"},{"location":"controller/#runtime-configuration-with-router","title":"Runtime Configuration with <code>router()</code>","text":"<p>Sometimes you want to keep your controller abstract and provide configuration when including it in your app. You can pass an optional configuration dictionary to the <code>router()</code> class method:</p> <pre><code>from fastioc.controller.definitions import APIRouterParams\n\n# Abstract controller (no config)\nclass GenericController(APIController):\n    @get('/')\n    def index(self):\n        return {\"message\": \"Hello\"}\n\n# Provide config at runtime\napp = FastAPI()\n\n# Option 1: Dictionary\napp.include_router(GenericController.router({\n    'prefix': '/api/v1',\n    'tags': ['API V1']\n}))\n\n# Option 2: Typed dictionary for IDE support\nconfig: APIRouterParams = {\n    'prefix': '/api/v2',\n    'tags': ['API V2'],\n    'deprecated': True\n}\napp.include_router(GenericController.router(config))\n</code></pre>"},{"location":"controller/#controller-dependencies-in-config","title":"Controller Dependencies in Config","text":"<p>You can specify dependencies that apply to all routes in the controller via the <code>dependencies</code> key:</p> <pre><code>container = Container()\ncontainer.add_singleton(IGlobalService, GlobalService)\ncontainer.add_singleton(IAuthService, AuthService)\n\nclass SecureController(APIController):\n    config = {\n        'prefix': '/secure',\n        'container': container,\n        'dependencies': [IGlobalService, IAuthService]  # Run on ALL routes\n    }\n\n    @get('/data')\n    def get_data(self):\n        # IGlobalService and IAuthService are resolved for this route\n        return {\"data\": \"secure\"}\n\n    @post('/update')\n    def update_data(self):\n        # Same dependencies apply here too\n        return {\"status\": \"updated\"}\n</code></pre> <p>You can also add route-specific dependencies using the decorator:</p> <pre><code>class MixedController(APIController):\n    config = {\n        'prefix': '/mixed',\n        'container': container,\n        'dependencies': [IGlobalService]  # All routes\n    }\n\n    @get('/public')\n    def public_route(self):\n        # Only IGlobalService\n        return {\"public\": True}\n\n    @get('/admin', dependencies=[IAdminService])  # Additional dependency\n    def admin_route(self):\n        # Both IGlobalService AND IAdminService\n        return {\"admin\": True}\n</code></pre>"},{"location":"controller/#key-points","title":"Key Points","text":"<ul> <li>Use <code>APIController</code> to organize related endpoints into classes</li> <li>Import HTTP decorators from <code>fastioc.controller</code>: <code>get</code>, <code>post</code>, <code>put</code>, <code>delete</code>, etc.</li> <li>Configure via the <code>config</code> dictionary (full IDE support)</li> <li>Pass <code>container</code> in config to enable dependency injection (optional)</li> <li>Use class type hints for shared dependencies (available in all endpoints)</li> <li>Use <code>Annotated</code> for request data in class hints; normal syntax in <code>__init__</code></li> <li>Call <code>Controller.router()</code> as a class method, not on an instance</li> <li>Optionally pass runtime config to <code>router()</code> for abstract controllers</li> <li>Runtime config replaces class config completely (doesn't merge)</li> </ul>"},{"location":"controller/#related-documentation","title":"Related Documentation","text":"<ul> <li>Passing Data to Dependencies - Pattern 1: FastAPI Native Dependencies</li> <li>Nested Dependencies - Class Type Hints</li> <li>FastAPI APIRouter Documentation</li> </ul>"},{"location":"data/","title":"Passing Data to Dependencies","text":"<p>When building applications, you often need to pass configuration data, settings, or runtime parameters to your dependencies. This guide shows three common patterns for accomplishing this in FastIoC.</p>"},{"location":"data/#pattern-1-fastapi-native-dependencies","title":"Pattern 1: FastAPI Native Dependencies","text":"<p>FastIoC is fully compatible with FastAPI's native dependency injection system. You can use FastAPI's features to pass data from requests directly to your dependencies.</p>"},{"location":"data/#in-functions-and-generators","title":"In Functions and Generators","text":"<p>You can receive request data as parameters in function or generator dependencies, exactly like in FastAPI:</p> <pre><code>from fastapi import FastAPI, Query, Header, Path\nfrom fastioc import Container\nfrom typing import Annotated\n\napp = FastAPI()\ncontainer = Container()\n\n# Function dependency that receives request data\ndef get_pagination(\n    page: int = Query(1, ge=1),\n    page_size: int = Query(10, ge=1, le=100)\n) -&gt; dict:\n    return {\n        \"skip\": (page - 1) * page_size,\n        \"limit\": page_size\n    }\n\n# Service that uses pagination\nclass DataService:\n    def __init__(self, pagination: Annotated[dict, Depends(get_pagination)]):\n        self.pagination = pagination\n\n    def fetch_data(self):\n        return f\"Fetching data with skip={self.pagination['skip']}, limit={self.pagination['limit']}\"\n\ncontainer.add_scoped(DataService, DataService)\ncontainer.injectify(app)\n\n@app.get(\"/data\")\nasync def get_data(service: DataService):\n    return {\"result\": service.fetch_data()}\n</code></pre>"},{"location":"data/#in-class-__init__-parameters","title":"In Class <code>__init__</code> Parameters","text":"<p>In class <code>__init__</code> parameters, FastAPI features work just like they do in regular FastAPI dependencies:</p> <pre><code>from fastapi import Query, Header, Cookie\nfrom typing import Annotated\n\nclass AuthenticatedService:\n    def __init__(\n        self,\n        # FastAPI features work directly\n        api_key: Annotated[str, Header()],\n        user_id: Annotated[int, Query()],\n        session: Annotated[str, Cookie()] = \"default\",\n\n        # You can also mix with FastIoC dependencies\n        db: IDatabaseService\n    ):\n        self.api_key = api_key\n        self.user_id = user_id\n        self.session = session\n        self.db = db\n\n    def get_user_data(self):\n        return self.db.query(self.user_id)\n\ncontainer.add_scoped(IDatabaseService, DatabaseService)\ncontainer.add_scoped(AuthenticatedService, AuthenticatedService)\n</code></pre>"},{"location":"data/#in-class-type-hints-fastiocs-special-feature","title":"In Class Type Hints (FastIoC's Special Feature)","text":"<p>When using class-level type hints (FastIoC's unique feature), you MUST use FastAPI's annotations explicitly:</p> <pre><code>from fastapi import Query, Header, Cookie, Request\nfrom typing import Annotated\n\nclass SearchService:\n    # \u274c WRONG: Simple types don't work in class hints\n    # query: str  # This won't receive query parameter!\n\n    # \u2705 CORRECT: Must use FastAPI annotations\n    query: Annotated[str, Query()]\n    page: Annotated[int, Query(default=1)]\n    api_key: Annotated[str, Header()]\n\n    # \u2705 FastAPI special types work directly\n    request: Request\n\n    # \u2705 FastIoC dependencies work as usual\n    db: IDatabaseService\n\n    def search(self):\n        return self.db.search(\n            query=self.query,\n            page=self.page,\n            user_agent=self.request.headers.get(\"user-agent\")\n        )\n\ncontainer.add_scoped(IDatabaseService, DatabaseService)\ncontainer.add_scoped(SearchService, SearchService)\n</code></pre> <p>Important: The difference between <code>__init__</code> and class type hints:</p> <pre><code>class ServiceA:\n    # In __init__: Works like normal FastAPI\n    def __init__(\n        self,\n        user_id: int = Query()  # \u2705 Works\n    ):\n        self.user_id = user_id\n\nclass ServiceB:\n    # In class hints: MUST use Annotated\n    user_id: Annotated[int, Query()]  # \u2705 Works\n    # user_id: int = Query()          # \u274c Won't work!\n</code></pre> <p>See Nested Dependencies - Class Type Hints for more details.</p>"},{"location":"data/#complete-example","title":"Complete Example","text":"<pre><code>from fastapi import FastAPI, Query, Header, Depends\nfrom fastioc import Container\nfrom typing import Annotated\n\napp = FastAPI()\ncontainer = Container()\n\n# Function dependency\ndef get_auth_header(authorization: str = Header()) -&gt; str:\n    return authorization.replace(\"Bearer \", \"\")\n\n# Class with __init__ parameters\nclass UserService:\n    def __init__(\n        self,\n        user_id: int = Query(),\n        token: Annotated[str, Depends(get_auth_header)] = None,\n        db: IDatabaseService = None\n    ):\n        self.user_id = user_id\n        self.token = token\n        self.db = db\n\n# Class with type hints\nclass AdminService:\n    # Must use Annotated for request data in class hints\n    admin_key: Annotated[str, Header()]\n    action: Annotated[str, Query()]\n\n    # FastIoC dependencies work as usual\n    db: IDatabaseService\n\ncontainer.add_scoped(IDatabaseService, DatabaseService)\ncontainer.add_scoped(UserService, UserService)\ncontainer.add_scoped(AdminService, AdminService)\ncontainer.injectify(app)\n\n@app.get(\"/user\")\nasync def get_user(service: UserService):\n    return {\"user_id\": service.user_id, \"authenticated\": bool(service.token)}\n\n@app.get(\"/admin\")\nasync def admin_action(service: AdminService):\n    return {\"action\": service.action, \"key_valid\": bool(service.admin_key)}\n</code></pre>"},{"location":"data/#pattern-2-options-pattern","title":"Pattern 2: Options Pattern","text":"<p>The Options Pattern involves registering a dependency that contains shared or required data (like configuration, settings, or context), and then using it as a nested dependency in your services.</p>"},{"location":"data/#example-1-configuration-class","title":"Example 1: Configuration Class","text":"<pre><code>from dataclasses import dataclass\nfrom fastioc import Container\nfrom fastapi import FastAPI\n\n# Options/Configuration class\n@dataclass\nclass DatabaseConfig:\n    host: str\n    port: int\n    username: str\n    password: str\n    database: str\n\n# Service that depends on the configuration\nclass DatabaseService:\n\n    config: DatabaseConfig\n\n    def get_connection_string(self) -&gt; str:\n        return f\"postgresql://{self.config.username}@{self.config.host}:{self.config.port}/{self.config.database}\"\n\n# Setup\napp = FastAPI()\ncontainer = Container()\n\n# Register the configuration as a singleton\ndb_config = DatabaseConfig(\n    host=\"localhost\",\n    port=5432,\n    username=\"user\",\n    password=\"pass\",\n    database=\"mydb\"\n)\ncontainer.add_singleton(DatabaseConfig, lambda: db_config)\n\n# Register the service - it will automatically receive the config\ncontainer.add_scoped(DatabaseService, DatabaseService)\ncontainer.injectify(app)\n\n@app.get(\"/connection\")\nasync def get_connection(db: DatabaseService):\n    return {\"connection_string\": db.get_connection_string()}\n</code></pre>"},{"location":"data/#example-2-dictionary-provider","title":"Example 2: Dictionary Provider","text":"<pre><code>from typing import Dict, Any\nfrom fastioc import Container\nfrom fastapi import FastAPI\n\n# Function that returns configuration as a dictionary\ndef get_app_settings() -&gt; Dict[str, Any]:\n    return {\n        \"api_key\": \"secret-key-123\",\n        \"max_connections\": 100,\n        \"timeout\": 30,\n        \"feature_flags\": {\n            \"new_ui\": True,\n            \"beta_features\": False\n        }\n    }\n\n# Service that uses the configuration\nclass ApiClient:\n    def __init__(self, settings: Dict[str, Any]):\n        self.api_key = settings[\"api_key\"]\n        self.timeout = settings[\"timeout\"]\n\n    def make_request(self) -&gt; str:\n        return f\"Making request with API key: {self.api_key[:10]}...\"\n\n# Setup\napp = FastAPI()\ncontainer = Container()\n\n# Register the settings provider\ncontainer.add_singleton(Dict[str, Any], get_app_settings)\n\n# Register the service\ncontainer.add_scoped(ApiClient, ApiClient)\ncontainer.injectify(app)\n\n@app.get(\"/api-call\")\nasync def call_api(client: ApiClient):\n    return {\"result\": client.make_request()}\n</code></pre>"},{"location":"data/#example-3-updatable-configuration","title":"Example 3: Updatable Configuration","text":"<pre><code>from fastioc import Container\nfrom fastapi import FastAPI\n\n# Configuration manager that can be updated\nclass AppSettings:\n    def __init__(self):\n        self._settings = {\n            \"theme\": \"dark\",\n            \"language\": \"en\",\n            \"notifications\": True\n        }\n\n    def get(self, key: str, default=None):\n        return self._settings.get(key, default)\n\n    def update(self, key: str, value: Any):\n        self._settings[key] = value\n\n    def get_all(self) -&gt; dict:\n        return self._settings.copy()\n\n# Service that uses settings\nclass UIService:\n    settings: AppSettings\n\n    def get_theme(self) -&gt; str:\n        return self.settings.get(\"theme\")\n\n# Setup\napp = FastAPI()\ncontainer = Container()\n\n# Register settings as singleton (shared across requests)\ncontainer.add_singleton(AppSettings, AppSettings)\ncontainer.add_scoped(UIService, UIService)\ncontainer.injectify(app)\n\n@app.get(\"/theme\")\nasync def get_theme(ui: UIService):\n    return {\"theme\": ui.get_theme()}\n\n@app.post(\"/theme/{theme}\")\nasync def update_theme(theme: str, settings: AppSettings):\n    settings.update(\"theme\", theme)\n    return {\"message\": \"Theme updated\", \"theme\": theme}\n</code></pre>"},{"location":"data/#pattern-3-factory-pattern","title":"Pattern 3: Factory Pattern","text":"<p>The Factory Pattern involves wrapping your dependency with a function that creates its instance or calls it with specific parameters. This is useful when you need to pass configuration data or create customized instances at registration time.</p>"},{"location":"data/#example-1-simple-factory-function","title":"Example 1: Simple Factory Function","text":"<pre><code>from fastioc import Container\nfrom fastapi import FastAPI\n\n# Original service that needs parameters\nclass EmailService:\n    def __init__(self, smtp_host: str, smtp_port: int, sender: str):\n        self.smtp_host = smtp_host\n        self.smtp_port = smtp_port\n        self.sender = sender\n\n    def send(self, to: str, message: str) -&gt; str:\n        return f\"Sending from {self.sender} to {to} via {self.smtp_host}:{self.smtp_port}\"\n\n# Factory function that creates the service with specific configuration\ndef create_email_service() -&gt; EmailService:\n    return EmailService(\n        smtp_host=\"smtp.gmail.com\",\n        smtp_port=587,\n        sender=\"noreply@myapp.com\"\n    )\n\n# Setup\napp = FastAPI()\ncontainer = Container()\n\n# Register using the factory\ncontainer.add_scoped(EmailService, create_email_service)\ncontainer.injectify(app)\n\n@app.post(\"/send-email\")\nasync def send_email(email: EmailService, to: str, message: str):\n    result = email.send(to, message)\n    return {\"status\": result}\n</code></pre>"},{"location":"data/#example-2-factory-with-nested-dependencies","title":"Example 2: Factory with Nested Dependencies","text":"<pre><code>from fastioc import Container\nfrom fastapi import FastAPI\nfrom dataclasses import dataclass\n\n# Configuration\n@dataclass\nclass LoggerConfig:\n    log_level: str\n    format: str\n\n# Service that needs both config and custom parameters\nclass Logger:\n    def __init__(self, name: str, config: LoggerConfig):\n        self.name = name\n        self.log_level = config.log_level\n        self.format = config.format\n\n    def log(self, message: str) -&gt; str:\n        return f\"[{self.name}] [{self.log_level}] {message}\"\n\n# Factory that receives config from DI and adds custom parameters\ndef create_logger(config: LoggerConfig) -&gt; Logger:\n    # Custom logic to determine the logger name or other parameters\n    app_name = \"MyApplication\"\n    return Logger(name=app_name, config=config)\n\n# Setup\napp = FastAPI()\ncontainer = Container()\n\n# Register configuration\nlogger_config = LoggerConfig(log_level=\"INFO\", format=\"json\")\ncontainer.add_singleton(LoggerConfig, lambda: logger_config)\n\n# Register logger using factory (factory receives config automatically)\ncontainer.add_scoped(Logger, create_logger)\ncontainer.injectify(app)\n\n@app.get(\"/log\")\nasync def log_message(logger: Logger, message: str):\n    result = logger.log(message)\n    return {\"logged\": result}\n</code></pre>"},{"location":"data/#choosing-between-patterns","title":"Choosing Between Patterns","text":""},{"location":"data/#use-pattern-1-fastapi-native-dependencies-when","title":"Use Pattern 1: FastAPI Native Dependencies when:","text":"<ul> <li>You need to access request-specific data (query params, headers, cookies, etc.)</li> <li>Working with path parameters, request bodies, or uploaded files</li> <li>Need data that varies per request</li> <li>Want to use FastAPI's built-in validation and documentation features</li> </ul>"},{"location":"data/#use-pattern-2-options-pattern-when","title":"Use Pattern 2: Options Pattern when:","text":"<ul> <li>You have configuration that multiple services need to share</li> <li>Settings need to be updated at runtime</li> <li>You want to keep configuration centralized and reusable</li> <li>Multiple services depend on the same configuration data</li> <li>Configuration is independent of individual requests</li> </ul>"},{"location":"data/#use-pattern-3-factory-pattern-when","title":"Use Pattern 3: Factory Pattern when:","text":"<ul> <li>You need to pass specific parameters during dependency registration (not per request)</li> <li>Dependencies require complex initialization logic</li> <li>You need to create different instances with different configurations</li> <li>You want to combine DI-provided dependencies with custom parameters</li> <li>Configuration is static and determined at startup time</li> </ul>"},{"location":"dispose/","title":"Singleton Cleanup with <code>__dispose__</code>","text":"<p>When working with singleton dependencies, you often need to perform cleanup operations when your application shuts down such as closing database connections, releasing file handles, or cleaning up resources. FastIoC provides a clean way to handle this through the <code>__dispose__</code> method.</p>"},{"location":"dispose/#why-__dispose__-instead-of-generators","title":"Why <code>__dispose__</code> Instead of Generators?","text":"<p>In many dependency injection systems, you might use generators with <code>yield</code> for cleanup:</p> <pre><code>def get_db():\n    db = Database()\n    yield db\n    db.close()  # Cleanup after yield\n</code></pre> <p>However, generators and async generators cannot be registered as singletons in FastIoC. This is because generators are meant to be called multiple times, which conflicts with the singleton pattern of having one shared instance throughout the application lifecycle.</p> <p>Instead, FastIoC uses the <code>__dispose__</code> method pattern for singleton cleanup.</p>"},{"location":"dispose/#the-__dispose__-method","title":"The <code>__dispose__</code> Method","text":"<p>Any singleton class that defines a <code>__dispose__</code> method will have that method automatically called when you invoke <code>container.dispose()</code>. FastIoC supports both synchronous and asynchronous disposal.</p>"},{"location":"dispose/#basic-example","title":"Basic Example","text":"<pre><code>from fastioc import Container\n\nclass DatabaseService:\n    def __init__(self):\n        self.connection = self._create_connection()\n        print(\"Database connection opened\")\n\n    def _create_connection(self):\n        # Create database connection\n        return \"db_connection\"\n\n    def query(self, sql: str):\n        return f\"Executing: {sql}\"\n\n    def __dispose__(self):\n        \"\"\"Called automatically during container.dispose()\"\"\"\n        print(\"Database connection closed\")\n        self.connection = None\n\n# Register as singleton\ncontainer = Container()\ncontainer.add_singleton(DatabaseService, DatabaseService)\n</code></pre>"},{"location":"dispose/#async-disposal","title":"Async Disposal","text":"<p>FastIoC automatically detects and awaits async <code>__dispose__</code> methods:</p> <pre><code>import asyncio\n\nclass CacheService:\n    def __init__(self):\n        self.cache = {}\n        self.connected = True\n        print(\"Cache service started\")\n\n    async def __dispose__(self):\n        \"\"\"Async cleanup - will be awaited automatically\"\"\"\n        print(\"Flushing cache...\")\n        await asyncio.sleep(0.1)  # Simulate async cleanup\n        self.cache.clear()\n        self.connected = False\n        print(\"Cache service stopped\")\n\ncontainer = Container()\ncontainer.add_singleton(CacheService, CacheService)\n</code></pre>"},{"location":"dispose/#calling-containerdispose","title":"Calling <code>container.dispose()</code>","text":"<p>You must call <code>container.dispose()</code> during your application's shutdown to trigger all singleton cleanups. The recommended approach is to use FastAPI's lifespan events.</p>"},{"location":"dispose/#using-lifespan-context-manager","title":"Using Lifespan Context Manager","text":"<pre><code>from contextlib import asynccontextmanager\nfrom fastapi import FastAPI\nfrom fastioc import Container\n\n# Setup container\ncontainer = Container()\ncontainer.add_singleton(DatabaseService, DatabaseService)\ncontainer.add_singleton(CacheService, CacheService)\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    # Startup: Application initialization happens here\n    print(\"Application starting...\")\n    yield\n    # Shutdown: Cleanup happens after yield\n    print(\"Application shutting down...\")\n    await container.dispose()\n\n# Create app with lifespan\napp = FastAPI(lifespan=lifespan)\ncontainer.injectify(app)\n\n@app.get(\"/\")\nasync def root(db: DatabaseService, cache: CacheService):\n    return {\"message\": \"Hello World\"}\n</code></pre> <p>When the application shuts down, <code>container.dispose()</code> will automatically call the <code>__dispose__</code> method of all registered singletons.</p>"},{"location":"dispose/#accessing-fastapi-app-in-__dispose__","title":"Accessing FastAPI App in <code>__dispose__</code>","text":"<p>The <code>dispose()</code> method can optionally receive the FastAPI app instance, which you can then access in your <code>__dispose__</code> methods:</p> <pre><code>from fastapi import FastAPI\n\nclass ServiceWithAppAccess:\n    def __init__(self):\n        self.resource = \"allocated\"\n        print(\"Service initialized\")\n\n    def __dispose__(self, app: FastAPI):\n        \"\"\"Receives the FastAPI app during disposal\"\"\"\n        print(f\"Disposing service for app: {app.title}\")\n        print(f\"App state: {app.state}\")\n        self.resource = None\n\n# In your lifespan:\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    yield\n    await container.dispose(app)  # Pass app to dispose\n</code></pre> <p>FastIoC automatically detects if your <code>__dispose__</code> method has an <code>app</code> parameter and passes it accordingly. If your <code>__dispose__</code> doesn't need the app, simply omit the parameter.</p>"},{"location":"dispose/#key-points","title":"Key Points","text":"<ul> <li>Use <code>__dispose__</code> for singleton cleanup (generators aren't allowed for singletons)</li> <li>Both sync and async <code>__dispose__</code> methods are supported</li> <li>Call <code>container.dispose()</code> in your FastAPI lifespan shutdown</li> <li>Optionally receive the FastAPI <code>app</code> instance in <code>__dispose__(self, app: FastAPI)</code></li> <li>Errors in one disposal don't stop others from running</li> <li>All <code>__dispose__</code> methods are automatically detected and called no manual registration needed</li> </ul>"},{"location":"dispose/#related-documentation","title":"Related Documentation","text":"<ul> <li>FastAPI Lifespan Events</li> <li>FastAPI Startup and Shutdown</li> </ul>"},{"location":"hook/","title":"Container Hooks","text":"<p>FastIoC provides two powerful hooks that allow you to intercept and customize the dependency registration and resolution process. These hooks are useful for logging, validation, metrics, tracing, or applying custom behavior to your dependencies.</p>"},{"location":"hook/#available-hooks","title":"Available Hooks","text":""},{"location":"hook/#1-before_register_hook","title":"1. <code>before_register_hook</code>","text":"<p>This hook is executed before a dependency is registered in the container. It allows you to inspect, modify, or validate the dependency before it's stored.</p> <p>Signature: <pre><code>def before_register_hook(self, dependency: Dependency[Any]) -&gt; Dependency[Any]:\n    ...\n</code></pre></p> <p>Parameters: - <code>dependency.protocol</code> - The interface or protocol type - <code>dependency.implementation</code> - The implementation or factory - <code>dependency.lifetime</code> - The lifetime (SINGLETON, SCOPED, TRANSIENT)</p> <p>Returns: - The (optionally modified) dependency that will actually be registered</p>"},{"location":"hook/#2-before_resolve_hook","title":"2. <code>before_resolve_hook</code>","text":"<p>This hook is executed before a dependency is resolved from the container. It allows you to inspect, wrap, or modify the dependency just before it's provided to a consumer.</p> <p>Signature: <pre><code>def before_resolve_hook(self, dependency: Depends) -&gt; Depends:\n    ...\n</code></pre></p> <p>Parameters: - <code>dependency.dependency</code> - The callable that will produce the actual instance - <code>dependency.use_cache</code> - Whether the instance should be cached for reuse</p> <p>Returns: - The (optionally modified) Depends instance to be used in resolution</p>"},{"location":"hook/#how-to-use-hooks","title":"How to Use Hooks","text":"<p>You can override these methods by monkey patching them on your container instance:</p> <pre><code>from fastioc import Container\n\ncontainer = Container()\n\n# Define your hook function\ndef my_register_hook(dependency):\n    print(f\"Registering {dependency.protocol.__name__} -&gt; {dependency.implementation}\")\n    return dependency\n\n# Monkey patch the hook\ncontainer.before_register_hook = my_register_hook\n\n# Now all registrations will trigger the hook\ncontainer.add_scoped(IService, Service)\n</code></pre>"},{"location":"hook/#use-cases","title":"Use Cases","text":""},{"location":"hook/#logging-registration-and-resolution","title":"Logging Registration and Resolution","text":"<p>Track which dependencies are being registered and resolved:</p> <pre><code>from fastioc import Container\nfrom fastioc.definitions import Dependency\nfrom fastapi.params import Depends\n\ncontainer = Container()\n\n# Registration logging\ndef log_register(dependency: Dependency) -&gt; Dependency:\n    print(f\"=\ufffd Registering: {dependency.protocol.__name__}\")\n    print(f\"   Implementation: {dependency.implementation}\")\n    print(f\"   Lifetime: {dependency.lifetime}\")\n    return dependency\n\n# Resolution logging\ndef log_resolve(dependency: Depends) -&gt; Depends:\n    print(f\"=\n Resolving: {dependency.dependency.__name__}\")\n    return dependency\n\ncontainer.before_register_hook = log_register\ncontainer.before_resolve_hook = log_resolve\n\n# Now watch the logs as you register and use dependencies\ncontainer.add_scoped(IUserService, UserService)\n</code></pre> <p>Output: <pre><code>=\ufffd Registering: IUserService\n   Implementation: &lt;class 'UserService'&gt;\n   Lifetime: LifeTime.SCOPED\n</code></pre></p>"},{"location":"hook/#validation","title":"Validation","text":"<p>Ensure dependencies meet certain criteria before registration:</p> <pre><code>from fastioc.definitions import Dependency, LifeTime\n\ndef validate_register(dependency: Dependency) -&gt; Dependency:\n    # Ensure singleton implementations have __dispose__ method\n    if dependency.lifetime == LifeTime.SINGLETON:\n        if not hasattr(dependency.implementation, '__dispose__'):\n            print(f\"Warning: {dependency.implementation} is a singleton without __dispose__\")\n\n    # Ensure protocol names start with 'I'\n    if not dependency.protocol.__name__.startswith('I'):\n        raise ValueError(f\"Protocol {dependency.protocol.__name__} must start with 'I'\")\n\n    return dependency\n\ncontainer.before_register_hook = validate_register\n</code></pre>"},{"location":"hook/#metrics-and-tracing","title":"Metrics and Tracing","text":"<p>Track dependency resolution for performance monitoring:</p> <pre><code>import time\nfrom collections import defaultdict\n\nresolution_count = defaultdict(int)\nresolution_times = defaultdict(list)\n\ndef track_resolve(dependency: Depends) -&gt; Depends:\n    original_callable = dependency.dependency\n    name = original_callable.__name__\n\n    def timed_callable(*args, **kwargs):\n        start = time.time()\n        result = original_callable(*args, **kwargs)\n        duration = time.time() - start\n\n        resolution_count[name] += 1\n        resolution_times[name].append(duration)\n\n        return result\n\n    # Wrap the callable\n    dependency.dependency = timed_callable\n    return dependency\n\ncontainer.before_resolve_hook = track_resolve\n\n# After running your app\nprint(f\"Resolution stats: {dict(resolution_count)}\")\nprint(f\"Average times: {dict(resolution_times)}\")\n</code></pre>"},{"location":"hook/#modifying-dependencies","title":"Modifying Dependencies","text":"<p>Change the implementation or lifetime at registration time:</p> <pre><code>from fastioc.definitions import LifeTime\n\ndef modify_register(dependency: Dependency) -&gt; Dependency:\n    # Force all services to be singletons in production\n    if \"Service\" in dependency.protocol.__name__:\n        print(f\"=' Changing {dependency.protocol.__name__} to SINGLETON\")\n        dependency.lifetime = LifeTime.SINGLETON\n\n    return dependency\n\ncontainer.before_register_hook = modify_register\n</code></pre>"},{"location":"hook/#environment-based-behavior","title":"Environment-Based Behavior","text":"<p>Switch implementations based on environment:</p> <pre><code>import os\n\ndef env_based_register(dependency: Dependency) -&gt; Dependency:\n    # Use mock implementations in test environment\n    if os.getenv(\"ENV\") == \"test\":\n        impl_name = dependency.implementation.__name__\n        if impl_name.endswith(\"Service\"):\n            mock_name = f\"Mock{impl_name}\"\n            # Assume mock classes are available\n            if mock_class := globals().get(mock_name):\n                print(f\"&gt;\ufffd Using {mock_name} instead of {impl_name}\")\n                dependency.implementation = mock_class\n\n    return dependency\n\ncontainer.before_register_hook = env_based_register\n</code></pre>"},{"location":"hook/#complete-example","title":"Complete Example","text":"<p>Here's a complete example showing both hooks working together:</p> <pre><code>from fastapi import FastAPI\nfrom fastapi.testclient import TestClient\nfrom fastioc import Container\nfrom fastioc.definitions import Dependency\nfrom fastapi.params import Depends\n\n# Service definition\nclass INumberService:\n    def get_number(self) -&gt; int:\n        ...\n\nclass NumberService(INumberService):\n    def get_number(self) -&gt; int:\n        return 42\n\n# Setup\napp = FastAPI()\ncontainer = Container()\n\n# Track hook calls\nregister_number: int = 0\nresolve_number: int = 0\n\ndef register_hook(dependency: Dependency[INumberService]) -&gt; Dependency[INumberService]:\n    global register_number\n    # Call implementation to get the number\n    register_number = dependency.implementation().get_number()\n    print(f\"=\ufffd Registered: {dependency.protocol.__name__} (number: {register_number})\")\n    return dependency\n\ndef resolve_hook(dependency: Depends) -&gt; Depends:\n    global resolve_number\n    # Call the dependency callable to get instance\n    resolve_number = dependency.dependency().get_number()\n    print(f\"=\n Resolved: dependency (number: {resolve_number})\")\n    return dependency\n\n# Apply hooks\ncontainer.before_register_hook = register_hook\ncontainer.before_resolve_hook = resolve_hook\n\n# Register service\ncontainer.add_scoped(INumberService, NumberService)\ncontainer.injectify(app)\n\n# Create endpoint\n@app.get('/test')\nasync def endpoint(service: INumberService) -&gt; int:\n    return service.get_number()\n\n# Test\nclient = TestClient(app)\nresponse = client.get('/test')\ndata = response.json()\n\nprint(f\"Response: {data}\")\nprint(f\"Register number: {register_number}\")\nprint(f\"Resolve number: {resolve_number}\")\n\nassert data == register_number == resolve_number == 42\n</code></pre> <p>Output: <pre><code>=\ufffd Registered: INumberService (number: 42)\n=\n Resolved: dependency (number: 42)\nResponse: 42\nRegister number: 42\nResolve number: 42\n</code></pre></p>"},{"location":"hook/#hook-execution-flow","title":"Hook Execution Flow","text":"<pre><code>1. container.add_scoped(IService, Service)\n2. before_register_hook(Dependency(...)) -&gt; Your custom logic\n3. Dependency stored in container\n\n---\n\n4. Endpoint called, needs IService\n5. container.resolve(IService)\n6. before_resolve_hook(Depends(...)) -&gt; Your custom logic\n7. Dependency instance provided to endpoint\n</code></pre>"},{"location":"hook/#important-notes","title":"Important Notes","text":"<ul> <li>Hooks are optional - if not overridden, they do nothing</li> <li><code>before_register_hook</code> runs once per dependency registration</li> <li><code>before_resolve_hook</code> runs every time a dependency is resolved (first access per request for SCOPED)</li> <li>Hooks must return the dependency (modified or unmodified)</li> <li>You can modify the dependency object inside hooks</li> <li>\u26a0\ufe0f Be careful with performance in <code>before_resolve_hook</code> - it runs frequently</li> <li>\u26a0\ufe0f Errors in hooks will propagate and prevent registration/resolution</li> </ul>"},{"location":"hook/#common-patterns","title":"Common Patterns","text":""},{"location":"hook/#debug-mode-toggle","title":"Debug Mode Toggle","text":"<pre><code>DEBUG = True\n\ndef debug_register(dependency: Dependency) -&gt; Dependency:\n    if DEBUG:\n        print(f\"[DEBUG] Register: {dependency.protocol.__name__}\")\n    return dependency\n\ndef debug_resolve(dependency: Depends) -&gt; Depends:\n    if DEBUG:\n        print(f\"[DEBUG] Resolve: {dependency.dependency.__name__}\")\n    return dependency\n\nif DEBUG:\n    container.before_register_hook = debug_register\n    container.before_resolve_hook = debug_resolve\n</code></pre>"},{"location":"hook/#audit-trail","title":"Audit Trail","text":"<pre><code>from datetime import datetime\n\naudit_log = []\n\ndef audit_register(dependency: Dependency) -&gt; Dependency:\n    audit_log.append({\n        \"timestamp\": datetime.now(),\n        \"action\": \"register\",\n        \"protocol\": dependency.protocol.__name__,\n        \"implementation\": dependency.implementation.__name__,\n        \"lifetime\": dependency.lifetime\n    })\n    return dependency\n\ncontainer.before_register_hook = audit_register\n\n# Later, export audit log\nimport json\nwith open(\"audit.json\", \"w\") as f:\n    json.dump(audit_log, f, indent=2, default=str)\n</code></pre>"},{"location":"hook/#related-documentation","title":"Related Documentation","text":"<ul> <li>Container Registration</li> <li>Dependency Resolution</li> <li>Project Structure at Scale</li> </ul>"},{"location":"injectify/","title":"Injectification: Integrating FastIoC with FastAPI","text":"<p>Before you can use dependency injection in your FastAPI application, you need to \"injectify\" your FastAPI application and routers. This tells FastIoC to intercept and inject dependencies into your endpoints.</p>"},{"location":"injectify/#basic-usage","title":"Basic Usage","text":"<p>The <code>injectify()</code> method integrates FastIoC with your FastAPI application:</p> <pre><code># main.py\nfrom fastapi import FastAPI\nfrom fastioc import Container\n\ncontainer = Container()\napp = FastAPI()\n\n# Injectify the FastAPI app\ncontainer.injectify(app)\n\n@app.get('/')\ndef index():\n    return {\"message\": \"Hello World\"}\n</code></pre> <p>\u26a0\ufe0f Important: You must call <code>injectify()</code> before defining your endpoints (routes). If you define routes before injectifying, those routes won't have dependency injection enabled.</p>"},{"location":"injectify/#injectifying-routers","title":"Injectifying Routers","text":"<p>When working with APIRouter, you must injectify each router individually. Here's a simple example:</p> <pre><code># main.py\nfrom fastapi import FastAPI, APIRouter\nfrom fastioc import Container\n\ncontainer = Container()\napp = FastAPI()\nrouter = APIRouter()\n\n# Injectify both app and router\ncontainer.injectify(app, router)\n\n# Now define endpoints\n@app.get('/')\ndef index():\n    return {\"message\": \"Hello from app\"}\n\n@router.get('/items')\ndef list_items():\n    return {\"items\": []}\n\n# Include the router\napp.include_router(router)\n</code></pre> <p>\u26a0\ufe0f Important: <code>app.include_router()</code> does NOT automatically injectify the router. You must explicitly call <code>container.injectify(router)</code> before defining endpoints on that router.</p>"},{"location":"injectify/#large-scale-applications","title":"Large-Scale Applications","text":"<p>In larger applications with multiple files, importing a router module executes the endpoint definitions. You need to set up your container in a separate file first:</p> <pre><code># project/container.py\nfrom fastioc import Container\nfrom project.interfaces import IUserService\nfrom project.services import UserService\n\ncontainer = Container()\n\n# Register dependencies\ncontainer.add_scoped(IUserService, UserService)\n</code></pre> <pre><code># project/routers/users.py\nfrom fastapi import APIRouter\nfrom project.interfaces import IUserService\nfrom project.container import container\n\nrouter = APIRouter()\n\n# Injectify the router before defining endpoints\ncontainer.injectify(router)\n\n@router.get('/users/{user_id}')\ndef get_user(user_id: int, service: IUserService):\n    return service.get_user(user_id)\n</code></pre> <pre><code># main.py\nfrom fastapi import FastAPI\nfrom project.container import container\nfrom project.routers import users\n\napp = FastAPI()\n\n# Injectify the app if you define endpoints directly on it\n# container.injectify(app)\n\n# Now include the router (already injectified)\napp.include_router(users.router)\n</code></pre>"},{"location":"injectify/#multiple-injectify-calls","title":"Multiple Injectify Calls","text":"<p>You can call <code>injectify()</code> multiple times if needed. This is useful when you need to injectify components created at different times:</p> <pre><code># project/container.py\nfrom fastioc import Container\n\ncontainer = Container()\n# Register dependencies here...\n</code></pre> <pre><code># project/routers/admin.py\nfrom fastapi import APIRouter\nfrom project.container import container\n\nrouter = APIRouter()\n\n# Injectify when the router is created\ncontainer.injectify(router)\n\n@router.get('/admin/stats')\ndef get_stats():\n    return {\"stats\": \"data\"}\n</code></pre> <pre><code># main.py\nfrom fastapi import FastAPI\nfrom project.container import container\n\napp = FastAPI()\n\n# Injectify the main app\ncontainer.injectify(app)\n\n# ... later in your code, dynamically load a router ...\n\nfrom project.routers import admin\n\n# Router is already injectified in its own module\napp.include_router(admin.router)\n</code></pre> <p>This flexibility is particularly useful in scenarios where: - Routers are dynamically loaded - You're building modular applications - Different parts of your app are initialized at different times</p>"},{"location":"injectify/#injectifying-multiple-targets","title":"Injectifying Multiple Targets","text":"<p>You can injectify multiple routers in a single call when they're created in the same file:</p> <pre><code># project/container.py\nfrom fastioc import Container\n\ncontainer = Container()\n# Register dependencies here...\n</code></pre> <pre><code># project/routers.py\nfrom fastapi import APIRouter\nfrom project.container import container\n\nusers_router = APIRouter()\nitems_router = APIRouter()\ndashboard_router = APIRouter()\n\n# Injectify all routers at once before defining endpoints\ncontainer.injectify(users_router, items_router, dashboard_router)\n\n@users_router.get('/users')\ndef list_users():\n    return {\"users\": []}\n\n@items_router.get('/items')\ndef list_items():\n    return {\"items\": []}\n\n@dashboard_router.get('/dashboard')\ndef get_dashboard():\n    return {\"data\": \"dashboard\"}\n</code></pre> <pre><code># main.py\nfrom fastapi import FastAPI\nfrom project.container import container\nfrom project.routers import users_router, items_router, dashboard_router\n\napp = FastAPI()\n\n# Injectify the app\ncontainer.injectify(app)\n\n# Include routers (already injectified)\napp.include_router(users_router, prefix=\"/api\")\napp.include_router(items_router, prefix=\"/api\")\napp.include_router(dashboard_router, prefix=\"/api\")\n</code></pre>"},{"location":"injectify/#registration-order","title":"Registration Order","text":"<p>The order of <code>injectify()</code> and dependency registration doesn't matter, but both must happen before defining endpoints that use those dependencies:</p>"},{"location":"injectify/#register-first-then-injectify","title":"\u2705 Register First, Then Injectify","text":"<pre><code># project/container.py\nfrom fastioc import Container\nfrom project.interfaces import IUserService\nfrom project.services import UserService\n\ncontainer = Container()\n\n# Register dependencies first\ncontainer.add_scoped(IUserService, UserService)\n</code></pre> <pre><code># main.py\nfrom fastapi import FastAPI\nfrom project.container import container\n\napp = FastAPI()\n\n# Then injectify\ncontainer.injectify(app)\n\n# Then define endpoints\n@app.get('/users/{id}')\ndef get_user(id: int, service: IUserService):\n    return service.get_user(id)\n</code></pre>"},{"location":"injectify/#injectify-first-then-register","title":"\u2705 Injectify First, Then Register","text":"<pre><code># main.py\nfrom fastapi import FastAPI\nfrom fastioc import Container\n\ncontainer = Container()\napp = FastAPI()\n\n# Injectify first\ncontainer.injectify(app)\n\n# Then register dependencies\nfrom project.interfaces import IUserService\nfrom project.services import UserService\ncontainer.add_scoped(IUserService, UserService)\n\n# Then define endpoints\n@app.get('/users/{id}')\ndef get_user(id: int, service: IUserService):\n    return service.get_user(id)\n</code></pre>"},{"location":"injectify/#wrong-endpoint-before-registrationinjectify","title":"\u274c Wrong: Endpoint Before Registration/Injectify","text":"<pre><code>from fastapi import FastAPI\nfrom fastioc import Container\n\ncontainer = Container()\napp = FastAPI()\n\n# Define endpoint first (WRONG!)\n@app.get('/users/{id}')\ndef get_user(id: int, service: IUserService):\n    return service.get_user(id)\n\n# Then injectify (TOO LATE!)\ncontainer.injectify(app)\ncontainer.add_scoped(IUserService, UserService)\n\n# This endpoint won't have dependency injection\n</code></pre>"},{"location":"injectify/#important-unregistered-dependencies","title":"\u26a0\ufe0f Important: Unregistered Dependencies","text":"<p>If you request a dependency that hasn't been registered in the container, FastIoC will not raise an error during startup. Instead, FastAPI will treat it as a regular type annotation, and requests will fail with 422 Unprocessable Entity.</p> <pre><code># project/interfaces.py\nclass IUserService(Protocol):\n    def get_user(self, id: int) -&gt; dict: ...\n\n# main.py\ncontainer = Container()\napp = FastAPI()\n\ncontainer.injectify(app)\n\n# Forgot to register IUserService!\n# container.add_scoped(IUserService, UserService)  # &lt;- Missing!\n\n@app.get('/users/{id}')\ndef get_user(id: int, service: IUserService):\n    return service.get_user(id)\n\n# Requests to this endpoint will return: 422 Unprocessable Entity\n# Because FastAPI can't resolve IUserService\n</code></pre> <p>Why this happens: FastIoC assumes unregistered types are not meant to be dependencies from the container, so it doesn't interfere with them. FastAPI then tries to extract them from the request (like query parameters), which fails.</p> <p>Solution: Always ensure you register your dependencies before they're used in endpoints:</p> <pre><code># \u2705 Correct\ncontainer.add_scoped(IUserService, UserService)\n\n@app.get('/users/{id}')\ndef get_user(id: int, service: IUserService):\n    return service.get_user(id)\n</code></pre>"},{"location":"injectify/#advanced-multiple-containers","title":"Advanced: Multiple Containers","text":"<p>For advanced use cases, you can use different containers for different apps or routers. This is useful when you want to isolate dependencies between different parts of your application:</p> <pre><code>from fastapi import FastAPI, APIRouter\nfrom fastioc import Container\n\n# Create separate containers\nmain_container = Container()\nadmin_container = Container()\n\napp = FastAPI()\nadmin_router = APIRouter()\n\n# Register different dependencies in each container\nmain_container.add_scoped(IUserService, UserService)\nadmin_container.add_scoped(IAdminService, AdminService)\n\n# Injectify with different containers\nmain_container.injectify(app)\nadmin_container.injectify(admin_router)\n\n@app.get('/users')\ndef list_users(service: IUserService):\n    # Uses main_container dependencies\n    return service.list_users()\n\n@admin_router.get('/admin/users')\ndef admin_list_users(service: IAdminService):\n    # Uses admin_container dependencies\n    return service.list_admin_users()\n\napp.include_router(admin_router)\n</code></pre> <p>This pattern allows you to: - Isolate dependencies between different modules - Use different implementations for the same interface in different parts of your app - Create cleaner separation of concerns in large applications</p>"},{"location":"injectify/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Dependency Registration - how to register dependencies with the container</li> <li>Understand Dependency Resolution - how to use registered dependencies in endpoints</li> <li>Explore Dependency Lifetimes - singleton, scoped, and transient behaviors</li> </ul>"},{"location":"lifetime/","title":"Dependency Lifetimes","text":"<p>Dependency lifetimes control how long a dependency instance lives and when it gets created. FastIoC provides three lifetime options: Scoped, Transient, and Singleton.</p> <p>Understanding lifetimes is crucial for managing resources, state, and performance in your application.</p>"},{"location":"lifetime/#scoped","title":"Scoped","text":"<p>Created once per request. This is equivalent to FastAPI's <code>Depends(...)</code>.</p> <pre><code>container.add_scoped(IUserService, UserService)\n</code></pre> <p>When to use: - Database connections/sessions - Request-specific state - User context for the current request - Services that need isolation between requests</p> <p>Behavior: - Created once at the start of each request - Same instance throughout one request - Different instance for each request - Disposed at the end of the request</p>"},{"location":"lifetime/#class-example","title":"Class Example","text":"<pre><code># project/services.py\nclass DatabaseSession(IDatabaseSession):\n    def __init__(self):\n        self.connection = create_connection()\n        print(f\"DatabaseSession created: {id(self)}\")\n\n    def query(self, sql: str):\n        return self.connection.execute(sql)\n\n# project/container.py\ncontainer.add_scoped(IDatabaseSession, DatabaseSession)\n</code></pre> <pre><code># When you make requests:\n# Request 1: DatabaseSession created: 140234567890  \u2190 New instance\n#            (same instance used throughout request 1)\n# Request 2: DatabaseSession created: 140234599999  \u2190 New instance\n#            (same instance used throughout request 2)\n</code></pre> <p>Note: For classes, the instance is cached per request.</p>"},{"location":"lifetime/#function-example","title":"Function Example","text":"<pre><code># project/dependencies.py\ndef get_current_user_id() -&gt; int:\n    # Simulate expensive operation\n    user_id = extract_from_token()\n    print(f\"Extracted user_id: {user_id}\")\n    return user_id\n\n# project/container.py\ncontainer.add_scoped(CurrentUserId, get_current_user_id)\n</code></pre> <pre><code>@app.get('/profile')\ndef get_profile(user_id1: CurrentUserId, user_id2: CurrentUserId):\n    # Extracted user_id: 42  \u2190 Called once per request\n    # user_id1 and user_id2 are the same cached value\n    assert user_id1 == user_id2  # \u2705 True\n    return {\"user_id\": user_id1}\n</code></pre> <p>Note: For functions, the return value is cached per request, not the function instance.</p>"},{"location":"lifetime/#generator-example","title":"Generator Example","text":"<p>Generators are perfect for scoped dependencies when you need setup and teardown:</p> <pre><code># project/dependencies.py\nfrom typing import Generator\n\ndef get_db_session() -&gt; Generator[DatabaseSession, None, None]:\n    print(\"Opening database connection\")\n    session = create_session()\n\n    try:\n        yield session  # Provided to the endpoint\n    finally:\n        print(\"Closing database connection\")\n        session.close()  # Cleanup runs at request end\n\n# project/container.py\ncontainer.add_scoped(IDatabaseSession, get_db_session)\n</code></pre> <pre><code># Request lifecycle:\n# 1. \"Opening database connection\"  \u2190 Setup (before endpoint)\n# 2. Endpoint executes with session\n# 3. \"Closing database connection\"  \u2190 Cleanup (after endpoint)\n</code></pre> <p>Both sync and async generators are supported - FastAPI handles them automatically:</p> <pre><code>async def get_async_session() -&gt; AsyncGenerator[Session, None]:\n    print(\"Opening async connection\")\n    session = await create_async_session()\n\n    try:\n        yield session\n    finally:\n        print(\"Closing async connection\")\n        await session.close()\n</code></pre>"},{"location":"lifetime/#transient","title":"Transient","text":"<p>Created every time it's requested. This is equivalent to FastAPI's <code>Depends(..., use_cache=False)</code>.</p> <pre><code>container.add_transient(IEmailService, EmailService)\n</code></pre> <p>When to use: - Lightweight services - Stateless operations - Services used once and discarded - When you need a fresh instance every time</p> <p>Behavior: - Created every time it's injected - Different instance even within the same request - Multiple injections = multiple instances - Disposed immediately after use</p>"},{"location":"lifetime/#class-example_1","title":"Class Example","text":"<pre><code># project/services.py\nclass EmailService:\n    def __init__(self):\n        print(f\"EmailService created: {id(self)}\")\n\n    def send(self, to: str, message: str):\n        print(f\"Sending email to {to}\")\n\n# project/container.py\ncontainer.add_transient(IEmailService, EmailService)\n</code></pre> <pre><code>@app.get('/send')\ndef send_emails(\n    email1: IEmailService,\n    email2: IEmailService\n):\n    # EmailService created: 140234567890  \u2190 First injection\n    # EmailService created: 140234599999  \u2190 Second injection (different instance!)\n    email1.send(\"user1@example.com\", \"Hello\")\n    email2.send(\"user2@example.com\", \"World\")\n    return {\"sent\": 2}\n</code></pre> <p>Note: For classes, a new instance is created every time.</p>"},{"location":"lifetime/#function-example_1","title":"Function Example","text":"<pre><code># project/dependencies.py\nimport uuid\n\ndef generate_request_id() -&gt; str:\n    request_id = str(uuid.uuid4())\n    print(f\"Generated request_id: {request_id}\")\n    return request_id\n\n# project/container.py\ncontainer.add_transient(RequestId, generate_request_id)\n</code></pre> <pre><code>@app.get('/track')\ndef track(id1: Annotated[str, RequestId], id2: Annotated[str, RequestId]):\n    # Generated request_id: abc-123  \u2190 First call\n    # Generated request_id: def-456  \u2190 Second call (different value!)\n    return {\"id1\": id1, \"id2\": id2}\n</code></pre> <p>Note: For functions, the function is called every time, returning a fresh value.</p>"},{"location":"lifetime/#generator-example_1","title":"Generator Example","text":"<p>Transient generators are useful for one-time resource management:</p> <pre><code># project/dependencies.py\nfrom typing import Generator\n\ndef get_temp_file() -&gt; Generator[str, None, None]:\n    filepath = create_temp_file()\n    print(f\"Created temp file: {filepath}\")\n\n    try:\n        yield filepath\n    finally:\n        delete_temp_file(filepath)\n        print(f\"Deleted temp file: {filepath}\")\n\n# project/container.py\ncontainer.add_transient(TempFile, get_temp_file)\n</code></pre> <pre><code>@app.post('/process')\ndef process(file1: TempFile, file2: TempFile):\n    # Created temp file: /tmp/abc  \u2190 First injection\n    # Created temp file: /tmp/def  \u2190 Second injection\n    # ... endpoint logic ...\n    # Deleted temp file: /tmp/abc  \u2190 Cleanup after endpoint\n    # Deleted temp file: /tmp/def  \u2190 Cleanup after endpoint\n    return {\"processed\": 2}\n</code></pre> <p>Both sync and async generators are supported - FastAPI handles them automatically.</p>"},{"location":"lifetime/#singleton","title":"Singleton","text":"<p>Created once for the entire application lifetime.</p> <pre><code>container.add_singleton(IConfigService, ConfigService)\n</code></pre> <p>When to use: - Configuration that doesn't change - Shared caches - Connection pools - Application-wide state - Services without request-specific state</p> <p>Behavior: - Created on first use - Same instance for every request - Lives until application shutdown - Shared across all requests and users</p>"},{"location":"lifetime/#class-example_2","title":"Class Example","text":"<pre><code># project/services.py\nclass ConfigService(IConfigService):\n    def __init__(self):\n        self.config = load_config()\n        print(f\"ConfigService created: {id(self)}\")\n\n    def get_setting(self, key: str) -&gt; str:\n        return self.config.get(key)\n\n# project/container.py\ncontainer.add_singleton(IConfigService, ConfigService)\n</code></pre> <pre><code># When you make requests:\n# Request 1: ConfigService created: 140234567890  \u2190 Created once\n# Request 2: (uses same instance)\n# Request 3: (uses same instance)\n</code></pre> <p>Note: For classes, the instance is cached for the entire application lifetime.</p>"},{"location":"lifetime/#function-example_2","title":"Function Example","text":"<pre><code># project/dependencies.py\ndef load_app_config() -&gt; dict:\n    print(\"Loading configuration from file\")\n    config = read_config_file()\n    return config\n\n# project/container.py\ncontainer.add_singleton(AppConfig, load_app_config)\n</code></pre> <pre><code># First request:\n# Loading configuration from file  \u2190 Called once\n# ... returns config dict ...\n\n# Subsequent requests:\n# (returns cached config dict, function never called again)\n</code></pre> <p>Note: For functions, the return value is cached for the entire application lifetime.</p>"},{"location":"lifetime/#no-generators-allowed","title":"No Generators Allowed","text":"<p>Singletons cannot be generators or async generators:</p> <pre><code># \u274c WRONG: This will raise SingletonGeneratorError\ndef get_database() -&gt; Generator[Database, None, None]:\n    db = Database()\n    try:\n        yield db\n    finally:\n        db.close()\n\ncontainer.add_singleton(IDatabaseSession, get_database)  # \u274c Error!\n</code></pre> <p>Why? Generators can only be used once. After yielding a value and reaching the end, they cannot be reused. Since singletons are meant to be reused across the entire application, generators don't make sense as singletons.</p> <p>See the <code>SingletonGeneratorError</code> API reference for more details.</p> <p>Solution 1: Use a regular class or function for singletons:</p> <pre><code># \u2705 CORRECT: Use a class\nclass DatabasePool:\n    def __init__(self):\n        self.pool = create_connection_pool()\n\n    def get_connection(self):\n        return self.pool.get_connection()\n\ncontainer.add_singleton(IDatabasePool, DatabasePool)  # \u2705 OK\n</code></pre> <p>Solution 2: Use scoped/transient for generators:</p> <pre><code># \u2705 CORRECT: Use scoped for generators\ncontainer.add_scoped(IDatabaseSession, get_database)  # \u2705 OK\n</code></pre> <p>\u26a1\ufe0fSolution 3: If you need cleanup for singleton resources, use the dispose feature:</p> <p><pre><code># \u2705 CORRECT: Use singleton with dispose for cleanup\nclass DatabasePool:\n    def __init__(self):\n        self.pool = create_connection_pool()\n\n    def __dispose__(self): # also you can use `async def`, FastIoC will automatically handle it\n        self.pool.close_all()\n\ncontainer.add_singleton(IDatabasePool, DatabasePool)\n# Cleanup will run at application shutdown (see dispose documentation)\n</code></pre> \u26a0\ufe0f Note: before using this feature you must config it first, see here.</p>"},{"location":"lifetime/#lifetime-comparison","title":"Lifetime Comparison","text":"Lifetime Created Shared Disposed FastAPI Equivalent Scoped Once per request Within same request At request end <code>Depends(...)</code> Transient Every injection Never shared After use <code>Depends(..., use_cache=False)</code> Singleton Once per application Across all requests At app shutdown (Not directly available in FastAPI)"},{"location":"lifetime/#visual-example","title":"Visual Example","text":"<p>Here's how different lifetimes behave across requests:</p> <pre><code>from project.interfaces import IConfigService, IDatabaseSession, IEmailService\nfrom project.container import container\n\n# Register with different lifetimes\ncontainer.add_singleton(IConfigService, ConfigService)\ncontainer.add_scoped(IDatabaseSession, DatabaseSession)\ncontainer.add_transient(IEmailService, EmailService)\n\n@app.get('/example')\ndef example(\n    config1: IConfigService,\n    config2: IConfigService,\n    db1: IDatabaseSession,\n    db2: IDatabaseSession,\n    email1: IEmailService,\n    email2: IEmailService\n):\n    # Singleton: config1 and config2 are THE SAME instance\n    assert config1 is config2  # \u2705 True\n\n    # Scoped: db1 and db2 are THE SAME instance (within this request)\n    assert db1 is db2  # \u2705 True\n\n    # Transient: email1 and email2 are DIFFERENT instances\n    assert email1 is not email2  # \u2705 True\n\n    return {\"status\": \"ok\"}\n</code></pre> <p>Output across two requests:</p> <pre><code>Request 1:\n  ConfigService created: 12345      \u2190 Singleton (created once)\n  DatabaseSession created: 67890    \u2190 Scoped (new for request 1)\n  EmailService created: 11111       \u2190 Transient (new for email1)\n  EmailService created: 22222       \u2190 Transient (new for email2)\n\nRequest 2:\n  (ConfigService reused: 12345)     \u2190 Singleton (same instance)\n  DatabaseSession created: 99999    \u2190 Scoped (new for request 2)\n  EmailService created: 33333       \u2190 Transient (new for email1)\n  EmailService created: 44444       \u2190 Transient (new for email2)\n</code></pre>"},{"location":"lifetime/#choosing-the-right-lifetime","title":"Choosing the Right Lifetime","text":"<p>Use this decision tree:</p> <pre><code>Does it need to be shared across ALL requests?\n\u251c\u2500 YES \u2192 Use Singleton\n\u2502         (config, caches, connection pools)\n\u2502\n\u2514\u2500 NO \u2192 Does it need to be shared within ONE request?\n         \u251c\u2500 YES \u2192 Use Scoped\n         \u2502         (database sessions, request context)\n         \u2502\n         \u2514\u2500 NO \u2192 Use Transient\n                   (lightweight services, one-time operations)\n</code></pre> <p>Common Patterns:</p> <pre><code># Singleton: Application-wide shared state\ncontainer.add_singleton(IConfiguration, ProductionConfiguration)\ncontainer.add_singleton(ICache, RedisCache)\ncontainer.add_singleton(IConnectionPool, DatabasePool)\n\n# Scoped: Per-request state\ncontainer.add_scoped(IDatabaseSession, AsyncPostgreSQLDatabaseSession)\ncontainer.add_scoped(ICurrentUser, CurrentUserContext)\ncontainer.add_scoped(IUnitOfWork, UnitOfWork)\n\n# Transient: Stateless operations\ncontainer.add_transient(IEmailSender, GoogleEmailSender)\ncontainer.add_transient(IDataValidator, TransactionDataValidator)\ncontainer.add_transient(ILogger, InfluxDBLogger)\n</code></pre>"},{"location":"lifetime/#advanced-callable-class-instances-with-lifetimes","title":"Advanced: Callable Class Instances with Lifetimes","text":"<p>When using callable class instances (classes with <code>__call__</code> method), the lifetime behavior works differently because you're registering an instance rather than a class or function.</p>"},{"location":"lifetime/#with-singleton-not-recommended","title":"\u274c With Singleton (Not Recommended)","text":"<p>When you register a callable instance as singleton, FastIoC calls <code>__call__</code> once and caches that return value for the entire application lifetime:</p> <pre><code>class Counter:\n    def __init__(self):\n        self.count = 0\n\n    def __call__(self) -&gt; int:\n        self.count += 1\n        return self.count\n\ncounter_instance = Counter()\ncontainer.add_singleton(CounterValue, counter_instance)\n</code></pre> <pre><code>@app.get('/count1')\ndef get_count1(value: CounterValue):\n    return {\"count\": value}  # Always returns 1\n\n@app.get('/count2')\ndef get_count2(value: CounterValue):\n    return {\"count\": value}  # Always returns 1 (same cached value!)\n</code></pre> <p>What happens: 1. First request: <code>__call__()</code> is invoked \u2192 returns <code>1</code> \u2192 cached 2. All subsequent requests: The cached value <code>1</code> is returned, <code>__call__()</code> is never called again</p> <p>This is usually not what you want with callable instances. Only use singleton for callable instances if you fully understand this behavior and it's exactly what you need.</p>"},{"location":"lifetime/#with-scoped-recommended","title":"\u26a1\ufe0fWith Scoped (Recommended)","text":"<p>This is where callable instances shine! When registered as scoped, the instance persists but <code>__call__</code> is invoked once per request. This gives you a \"scoped proxy\" pattern (similar to Spring Boot), allowing you to:</p> <ul> <li>Maintain state across the application lifetime (the instance persists)</li> <li>Access request-specific context when <code>__call__</code> is invoked</li> <li>Combine singleton-like persistence with per-request execution</li> </ul> <pre><code>class RequestContextTracker:\n    def __init__(self):\n        self.total_requests = 0  # Persists across all requests\n        self.request_ids = []\n\n    def __call__(self, request: Request) -&gt; dict:\n        # Called once per request - has access to request context!\n        self.total_requests += 1\n        request_id = request.headers.get(\"X-Request-ID\")\n        self.request_ids.append(request_id)\n\n        return {\n            \"current_request_id\": request_id,\n            \"total_requests\": self.total_requests\n        }\n\ntracker = RequestContextTracker()\ncontainer.add_scoped(RequestContext, tracker)\n</code></pre> <pre><code>@app.get('/stats')\ndef get_stats(context: RequestContext):\n    # Request 1: {\"current_request_id\": \"abc\", \"total_requests\": 1}\n    # Request 2: {\"current_request_id\": \"def\", \"total_requests\": 2}\n    # The instance state accumulates across requests!\n    return context\n</code></pre> <p>Thanks to Python's flexibility, the instance can access both: - Application-wide state (instance attributes persist) - Request-specific context (when <code>__call__</code> is invoked per request)</p>"},{"location":"lifetime/#with-transient","title":"\u26a1\ufe0fWith Transient","text":"<p>With transient lifetime, <code>__call__</code> is invoked every time the dependency is injected, even within the same request:</p> <pre><code>class UniqueIdGenerator:\n    def __init__(self):\n        self.generated_count = 0  # Persists across all calls\n\n    def __call__(self) -&gt; str:\n        # Called every injection\n        self.generated_count += 1\n        return f\"id-{self.generated_count}\"\n\nid_gen = UniqueIdGenerator()\ncontainer.add_transient(UniqueId, id_gen)\n</code></pre> <pre><code>@app.get('/ids')\ndef get_ids(id1: UniqueId, id2: UniqueId):\n    # id1: \"id-1\"  \u2190 First injection\n    # id2: \"id-2\"  \u2190 Second injection (different value!)\n    # Instance state persists: generated_count = 2\n    return {\"id1\": id1, \"id2\": id2}\n</code></pre> <p>This pattern allows you to generate unique values while maintaining global state about how many have been generated.</p>"},{"location":"lifetime/#related-topics","title":"Related Topics","text":"<ul> <li>Callable Class Instances - Learn about using callable instances as dependencies</li> <li>Nested Dependencies - Understand lifetime rules when dependencies depend on other dependencies, including <code>SingletonLifetimeViolationError</code></li> <li>Dispose (Singleton Clean-up) - Learn how to properly dispose of singleton resources when the application shuts down</li> </ul>"},{"location":"lifetime/#advanced-singletons-in-production-deployments","title":"Advanced: Singletons in Production Deployments","text":"<p>Multiprocessing and Thread Safety Considerations</p> <p>When deploying FastAPI with multiple workers (using Gunicorn, Uvicorn workers, etc.), be aware of these singleton behaviors:</p>"},{"location":"lifetime/#one-singleton-per-worker-process","title":"One Singleton Per Worker Process","text":"<p>When you deploy with multiple workers, each worker process gets its own singleton instance:</p> <pre><code># Running with 4 workers\nuvicorn main:app --workers 4\n</code></pre> <p>This creates 4 separate singleton instances - one per worker. Singletons are not shared across worker processes. Each worker has its own isolated Python interpreter and memory space.</p> <p>Implications: - Singleton state is not shared between workers - In-memory caches are duplicated across workers - Counters and statistics are per-worker, not global - If you need true application-wide state, use external storage (Redis, database, etc.)</p>"},{"location":"lifetime/#thread-safety","title":"Thread Safety","text":"<p>When using singleton dependencies in a multiprocessing/multithreaded environment, ensure your singleton objects are thread-safe:</p> <pre><code># \u274c NOT thread-safe\nclass UnsafeCounter:\n    def __init__(self):\n        self.count = 0\n\n    def increment(self):\n        self.count += 1  # Race condition!\n        return self.count\n\n# \u2705 Thread-safe\nfrom threading import Lock\n\nclass SafeCounter:\n    def __init__(self):\n        self.count = 0\n        self._lock = Lock()\n\n    def increment(self):\n        with self._lock:\n            self.count += 1\n            return self.count\n</code></pre> <p>Common non-thread-safe operations: - Incrementing counters (<code>count += 1</code>) - Appending to lists (<code>list.append()</code>) - Modifying dictionaries (<code>dict[key] = value</code>) - File I/O without locks</p> <p>Use Python's <code>threading.Lock</code>, <code>threading.RLock</code>, or thread-safe data structures (like <code>queue.Queue</code>) when modifying singleton state from multiple threads.</p>"},{"location":"lifetime/#advanced-how-lifetimes-work-internally","title":"Advanced: How Lifetimes Work Internally","text":"<p>Technical Details for Advanced Users</p> <p>FastIoC handles caching differently based on the lifetime:</p>"},{"location":"lifetime/#scoped-transient-classes","title":"Scoped &amp; Transient (Classes)","text":"<ul> <li>Scoped: Instance is created once and cached per request</li> <li>Transient: New instance created on every injection</li> </ul>"},{"location":"lifetime/#scoped-transient-functions","title":"Scoped &amp; Transient (Functions)","text":"<ul> <li>Scoped: Function called once, return value cached per request</li> <li>Transient: Function called every time, returns fresh value</li> </ul> <p>This matches FastAPI's behavior exactly.</p>"},{"location":"lifetime/#singleton-classes","title":"Singleton (Classes)","text":"<ul> <li>FastIoC creates the instance once and stores it internally</li> <li>The registered dependency becomes a function that returns the stored instance</li> <li>This ensures the same instance is always returned</li> </ul>"},{"location":"lifetime/#singleton-functions","title":"Singleton (Functions)","text":"<ul> <li>FastIoC calls the function once and stores the return value</li> <li>Subsequent resolutions return the cached value</li> <li>The function is never called again</li> </ul> <p>Example: <pre><code>container.add_singleton(IConfig, ServiceConfig)\n\n# Internally becomes something like:\n_instance = None\ndef get_config():\n    global _instance\n    if _instance is None:\n        _instance = ServiceConfig()  # Called once\n    return _instance  # Always returns same instance\n</code></pre></p> <p>This is why generators don't work as singletons.</p>"},{"location":"lifetime/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Nested Dependencies - how dependencies can depend on other dependencies</li> <li>Understand Dependency Overrides - replacing dependencies for testing</li> <li>Explore Dispose (Singleton Clean-up) - properly cleaning up singleton resources</li> </ul>"},{"location":"log/","title":"Logging","text":"<p>FastIoC provides comprehensive logging to help you understand what's happening inside your dependency injection container. The logging system tracks container initialization, dependency registration, resolution, disposal, and potential issues.</p>"},{"location":"log/#enabling-logs","title":"Enabling Logs","text":"<p>FastIoC uses Python's standard <code>logging</code> module with the logger name <code>\"FastIoC\"</code>. To enable and configure logging:</p> <pre><code>import logging\n\n# Get the FastIoC logger\nlogger = logging.getLogger(\"FastIoC\")\n\n# Set the logging level\nlogger.setLevel(logging.DEBUG)  # Show all logs\n\n# Optional: Add a custom handler if needed\nhandler = logging.StreamHandler()\nhandler.setFormatter(logging.Formatter(\"%(name)s: %(levelname)s: %(message)s\"))\nlogger.addHandler(handler)\n</code></pre>"},{"location":"log/#log-levels","title":"Log Levels","text":"<p>FastIoC uses different log levels for different types of events:</p>"},{"location":"log/#debug-application-events","title":"DEBUG - Application Events","text":"<p>The DEBUG level logs normal application events and operations. This is useful for understanding the flow of dependency registration and resolution.</p> <p>Events logged at DEBUG level:</p> <ul> <li> <p>Container initialization <pre><code>FastIoC: DEBUG: IoC/DI Container initialized ...\n</code></pre></p> </li> <li> <p>Dependency registration <pre><code>FastIoC: DEBUG: Dependency \"UserService\" registered with \"SCOPED\" lifetime for protocol: \"IUserService\"\n</code></pre></p> </li> <li> <p>Singleton initialization <pre><code>FastIoC: DEBUG: Singleton dependency \"DatabaseService\" initialized\n</code></pre></p> </li> <li> <p>Disposal registration <pre><code>FastIoC: DEBUG: Disposal registered for dependency \"DatabaseService\"\n</code></pre></p> </li> <li> <p>Dependency resolution <pre><code>FastIoC: DEBUG: Resolve called for protocol \"IUserService\"\n</code></pre></p> </li> <li> <p>Nested dependency resolution <pre><code>FastIoC: DEBUG: Resolved Protocol \"IDatabaseService\" as nested dependency for \"UserService\"\nFastIoC: DEBUG: Resolved Protocol \"IEmailService\" as nested dependency for \"UserService\" (from class annotations)\n</code></pre></p> </li> <li> <p>FastAPI built-in resolution <pre><code>FastIoC: DEBUG: Resolved FastAPI built-in \"Request\" as nested dependency for \"MyService\"\n</code></pre></p> </li> <li> <p>Hook execution <pre><code>FastIoC: DEBUG: Registration hook executed for dependency \"IUserService-&gt;UserService@SCOPED\"\nFastIoC: DEBUG: Resolve hook executed for protocol \"IUserService\"\n</code></pre></p> </li> <li> <p>Dependency override <pre><code>FastIoC: DEBUG: Registered dependency \"IUserService\" overridden\nFastIoC: DEBUG: Registered dependency \"IEmailService\" overridden by Mock Container\n</code></pre></p> </li> <li> <p>Disposal execution <pre><code>FastIoC: DEBUG: Dependency \"DatabaseService\" disposed\n</code></pre></p> </li> <li> <p>FastAPI integration <pre><code>FastIoC: DEBUG: FastAPI application injectified\nFastIoC: DEBUG: FastAPI router injectified\n</code></pre></p> </li> </ul>"},{"location":"log/#info-skipped-dependencies","title":"INFO - Skipped Dependencies","text":"<p>The INFO level logs when FastIoC skips resolving a dependency because it's not registered in the container (and it's not a built-in type, FastAPI special type, or Pydantic model).</p> <p>Events logged at INFO level:</p> <ul> <li> <p>Unregistered protocol skipped <pre><code>FastIoC: INFO: Skipped protocol \"ICustomService\": No registered dependency found\n</code></pre></p> </li> <li> <p>Nested unregistered protocol skipped <pre><code>FastIoC: INFO: (Nested)Skipped protocol \"IHelperService\": No registered dependency found\n</code></pre></p> </li> </ul> <p>This helps you identify dependencies that might be missing from your container configuration.</p>"},{"location":"log/#warning-potential-issues","title":"WARNING - Potential Issues","text":"<p>The WARNING level logs situations that might indicate configuration problems or unexpected behavior, but don't prevent the application from running.</p> <p>Events logged at WARNING level:</p> <ul> <li> <p>Scoped dependency depends on transient <pre><code>FastIoC: WARNING: Request-scoped dependency \"UserService\" depends on transient dependency \"HelperService\"\n</code></pre>   This warns you that a scoped dependency depends on a transient one, which might not be what you intended (the transient will be recreated each time).</p> </li> <li> <p>Built-in type registered as protocol <pre><code>FastIoC: WARNING: Dependency \"MyService\" registered for protocol \"dict\" which is a built-in, type, Pydantic model, FastAPI special class. This may override default behavior; make sure this is what you intend\n</code></pre>   This warns when you register a dependency for built-in Python types (like <code>str</code>, <code>int</code>, <code>dict</code>), Pydantic models, or FastAPI special classes (like <code>Request</code>, <code>Response</code>). This can override FastAPI's default behavior.</p> </li> </ul>"},{"location":"log/#exception-errors-during-disposal","title":"EXCEPTION - Errors During Disposal","text":"<p>The EXCEPTION level logs errors that occur during the disposal process. These errors don't stop other dependencies from being disposed.</p> <p>Events logged at EXCEPTION level:</p> <ul> <li>Disposal error <pre><code>FastIoC: EXCEPTION: Error disposing \"DatabaseService\": Connection already closed\n</code></pre></li> </ul>"},{"location":"log/#configuration-examples","title":"Configuration Examples","text":""},{"location":"log/#basic-setup-show-all-logs","title":"Basic Setup - Show All Logs","text":"<pre><code>import logging\nfrom fastioc import Container\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.DEBUG,\n    format=\"%(name)s: %(levelname)s: %(message)s\"\n)\n\n# Create container - you'll see initialization log\ncontainer = Container()\n</code></pre>"},{"location":"log/#production-setup-only-warnings-and-errors","title":"Production Setup - Only Warnings and Errors","text":"<pre><code>import logging\n\nlogger = logging.getLogger(\"FastIoC\")\nlogger.setLevel(logging.WARNING)  # Only show warnings and errors\n</code></pre>"},{"location":"log/#development-setup-verbose-logging","title":"Development Setup - Verbose Logging","text":"<pre><code>import logging\n\n# Get the FastIoC logger\nlogger = logging.getLogger(\"FastIoC\")\nlogger.setLevel(logging.DEBUG)\n\n# Create a detailed formatter\nformatter = logging.Formatter(\n    \"%(asctime)s - %(name)s - %(levelname)s - %(message)s\",\n    datefmt=\"%Y-%m-%d %H:%M:%S\"\n)\n\n# Add console handler\nconsole_handler = logging.StreamHandler()\nconsole_handler.setFormatter(formatter)\nlogger.addHandler(console_handler)\n\n# Optionally, log to file\nfile_handler = logging.FileHandler(\"fastioc.log\")\nfile_handler.setFormatter(formatter)\nlogger.addHandler(file_handler)\n</code></pre>"},{"location":"log/#selective-logging-different-levels-per-handler","title":"Selective Logging - Different Levels per Handler","text":"<pre><code>import logging\n\nlogger = logging.getLogger(\"FastIoC\")\nlogger.setLevel(logging.DEBUG)  # Capture all logs\n\n# Console: Only warnings and errors\nconsole = logging.StreamHandler()\nconsole.setLevel(logging.WARNING)\nconsole.setFormatter(logging.Formatter(\"%(levelname)s: %(message)s\"))\nlogger.addHandler(console)\n\n# File: Everything (DEBUG and above)\nfile_handler = logging.FileHandler(\"fastioc_debug.log\")\nfile_handler.setLevel(logging.DEBUG)\nfile_handler.setFormatter(logging.Formatter(\"%(asctime)s - %(levelname)s - %(message)s\"))\nlogger.addHandler(file_handler)\n</code></pre>"},{"location":"log/#complete-example-with-logging","title":"Complete Example with Logging","text":"<p>Here's a complete example showing what logs you might see during typical operations:</p> <pre><code>import logging\nfrom fastapi import FastAPI\nfrom fastioc import Container\n\n# Enable DEBUG logging\nlogging.basicConfig(\n    level=logging.DEBUG,\n    format=\"%(name)s: %(levelname)s: %(message)s\"\n)\n\n# Create container\n# LOG: FastIoC: DEBUG: IoC/DI Container initialized ...\ncontainer = Container()\n\n# Define services\nclass IDatabaseService:\n    pass\n\nclass IEmailService:\n    pass\n\nclass DatabaseService(IDatabaseService):\n    def __init__(self):\n        self.connected = True\n\n    def __dispose__(self):\n        self.connected = False\n\nclass EmailService(IEmailService):\n    def __init__(self, db: IDatabaseService):\n        self.db = db\n\n# Register dependencies\ncontainer.add_singleton(IDatabaseService, DatabaseService)\n# LOG: FastIoC: DEBUG: Singleton dependency \"DatabaseService\" initialized\n# LOG: FastIoC: DEBUG: Disposal registered for dependency \"DatabaseService\"\n# LOG: FastIoC: DEBUG: Dependency \"DatabaseService\" registered with \"SINGLETON\" lifetime for protocol: \"IDatabaseService\"\n\ncontainer.add_scoped(IEmailService, EmailService)\n# LOG: FastIoC: DEBUG: Resolved Protocol \"IDatabaseService\" as nested dependency for \"EmailService\"\n# LOG: FastIoC: DEBUG: Dependency \"EmailService\" registered with \"SCOPED\" lifetime for protocol: \"IEmailService\"\n\n# Create FastAPI app\napp = FastAPI()\n\n# Injectify\ncontainer.injectify(app)\n# LOG: FastIoC: DEBUG: FastAPI application injectified\n\n# Define endpoint\n@app.get(\"/test\")\nasync def test(email: IEmailService):\n    return {\"status\": \"ok\"}\n\n# When endpoint is called:\n# LOG: FastIoC: DEBUG: Resolve called for protocol \"IEmailService\"\n\n# During shutdown:\n# await container.dispose()\n# LOG: FastIoC: DEBUG: Dependency \"DatabaseService\" disposed\n</code></pre>"},{"location":"log/#understanding-log-output","title":"Understanding Log Output","text":""},{"location":"log/#tracking-dependency-resolution","title":"Tracking Dependency Resolution","text":"<p>When DEBUG logging is enabled, you can trace exactly how FastIoC resolves your dependencies:</p> <pre><code>FastIoC: DEBUG: Resolve called for protocol \"IUserService\"\nFastIoC: DEBUG: Resolved Protocol \"IDatabaseService\" as nested dependency for \"UserService\"\nFastIoC: DEBUG: Resolved Protocol \"IAuthService\" as nested dependency for \"UserService\"\nFastIoC: DEBUG: Resolved Protocol \"IEmailService\" as nested dependency for \"UserService\"\n</code></pre> <p>This shows that <code>UserService</code> depends on three other services, and FastIoC resolved all of them.</p>"},{"location":"log/#identifying-missing-dependencies","title":"Identifying Missing Dependencies","text":"<p>INFO logs help you spot dependencies that aren't registered:</p> <pre><code>FastIoC: INFO: Skipped protocol \"IOptionalService\": No registered dependency found\n</code></pre> <p>If you see this for a dependency you expected to be registered, check your container configuration.</p>"},{"location":"log/#catching-configuration-issues","title":"Catching Configuration Issues","text":"<p>WARNING logs alert you to potential problems:</p> <pre><code>FastIoC: WARNING: Request-scoped dependency \"UserService\" depends on transient dependency \"HelperService\"\n</code></pre> <p>This might indicate that you should register <code>HelperService</code> as scoped instead of transient for better performance and consistency.</p>"},{"location":"log/#disabling-logs","title":"Disabling Logs","text":"<p>To completely disable FastIoC logs:</p> <pre><code>import logging\n\nlogger = logging.getLogger(\"FastIoC\")\nlogger.setLevel(logging.CRITICAL)  # Only critical errors (effectively disables logs)\n# Or completely disable:\nlogger.disabled = True\n</code></pre>"},{"location":"log/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Development: Use <code>DEBUG</code> level to understand how dependencies are wired    <pre><code>logger.setLevel(logging.DEBUG)\n</code></pre></p> </li> <li> <p>Testing: Use <code>WARNING</code> level to catch configuration issues without noise    <pre><code>logger.setLevel(logging.WARNING)\n</code></pre></p> </li> <li> <p>Production: Use <code>WARNING</code> or <code>ERROR</code> level for minimal logging    <pre><code>logger.setLevel(logging.WARNING)\n</code></pre></p> </li> <li> <p>Debugging Issues: Enable <code>DEBUG</code> temporarily and log to a file    <pre><code>handler = logging.FileHandler(\"fastioc_debug.log\")\nhandler.setLevel(logging.DEBUG)\nlogger.addHandler(handler)\n</code></pre></p> </li> <li> <p>CI/CD: Disable logs during automated tests to reduce noise    <pre><code>logger.disabled = True\n</code></pre></p> </li> </ol>"},{"location":"log/#log-level-summary","title":"Log Level Summary","text":"Level Use Case Example Events DEBUG Development, understanding flow Container init, registration, resolution, disposal INFO Identifying skipped dependencies Unregistered protocols WARNING Catching potential issues Scoped -&gt; Transient dependency, built-in type registration EXCEPTION Disposal errors Failed cleanup operations"},{"location":"log/#related-documentation","title":"Related Documentation","text":"<ul> <li>Container Registration</li> <li>Nested Dependencies</li> <li>Singleton Cleanup</li> <li>Hooks</li> </ul>"},{"location":"nested/","title":"Nested Dependencies","text":"<p>Nested dependencies (also known as Sub-dependencies in FastAPI) occur when a dependency itself depends on other dependencies. FastIoC fully supports nested dependencies with automatic resolution - just like FastAPI's native dependency injection.</p> <p>FastIoC handles all the dependency resolution and passes them to FastAPI's <code>Depends()</code> under the hood, so everything works seamlessly.</p>"},{"location":"nested/#basic-concept","title":"Basic Concept","text":"<p>When you register a dependency that requires other dependencies, FastIoC automatically resolves the entire dependency chain:</p> <pre><code># Service A depends on Service B\nclass ServiceB:\n    def get_data(self) -&gt; str:\n        return \"data from B\"\n\nclass ServiceA:\n    def __init__(self, service_b: IServiceB):\n        self.service_b = service_b\n\n    def process(self) -&gt; str:\n        return f\"A processes: {self.service_b.get_data()}\"\n\n# Register both\ncontainer.add_scoped(IServiceB, ServiceB)\ncontainer.add_scoped(IServiceA, ServiceA)  # ServiceA automatically gets ServiceB injected\n</code></pre> <pre><code>@app.get('/process')\ndef process(service_a: IServiceA):\n    # ServiceB is automatically resolved and injected into ServiceA\n    return {\"result\": service_a.process()}\n</code></pre>"},{"location":"nested/#important-registration-order","title":"\u26a0\ufe0f Important: Registration Order","text":"<p>When registering nested dependencies, inner dependencies must be registered before outer dependencies that depend on them.</p> <p>Correct order:</p> <pre><code># \u2705 Register inner dependency first\ncontainer.add_scoped(IServiceB, ServiceB)      # Inner dependency\ncontainer.add_scoped(IServiceA, ServiceA)      # Outer dependency (depends on IServiceB)\n</code></pre> <p>Wrong order:</p> <pre><code># \u274c WRONG: Outer dependency registered first\ncontainer.add_scoped(IServiceA, ServiceA)      # Tries to resolve IServiceB, but it's not registered yet!\ncontainer.add_scoped(IServiceB, ServiceB)      # Too late\n</code></pre> <p>What happens if the order is wrong:</p> <p>FastIoC won't find the dependency registration and will leave it as-is. FastAPI will then try to parse it as a request parameter or Pydantic model, which will fail and return 422 Unprocessable Entity errors.</p> <p>If you encounter unexpected 422 errors, check that:</p> <ol> <li>All dependencies are registered in the container</li> <li>Inner dependencies are registered before outer ones</li> <li>See Unregistered Dependencies troubleshooting for more help</li> </ol>"},{"location":"nested/#nested-dependencies-in-functions-and-generators","title":"Nested Dependencies in Functions and Generators","text":"<p>Functions and generators can depend on other registered dependencies:</p> <pre><code># project/dependencies.py\ndef get_database_url() -&gt; str:\n    return \"postgresql://localhost/mydb\"\n\ndef get_connection(db_url: DatabaseUrl) -&gt; Connection:\n    # db_url is automatically resolved\n    return create_connection(db_url)\n\n# project/container.py\ncontainer.add_scoped(DatabaseUrl, get_database_url)\ncontainer.add_scoped(IConnection, get_connection)\n</code></pre>"},{"location":"nested/#with-generators","title":"With Generators","text":"<pre><code>from typing import Generator\n\ndef get_db_session(connection: IConnection) -&gt; Generator[Session, None, None]:\n    # connection is automatically resolved\n    session = create_session(connection)\n    try:\n        yield session\n    finally:\n        session.close()\n\ncontainer.add_scoped(IDatabaseSession, get_db_session)\n</code></pre> <p>Both sync and async are supported - FastAPI handles them automatically.</p>"},{"location":"nested/#nested-dependencies-in-classes","title":"Nested Dependencies in Classes","text":"<p>Classes can resolve dependencies in two powerful ways: through <code>__init__</code> parameters and through class-level type hints.</p>"},{"location":"nested/#method-1-resolution-in-__init__-standard","title":"Method 1: Resolution in <code>__init__</code> (Standard)","text":"<p>This is the standard way - dependencies are resolved and passed to the <code>__init__</code> method:</p> <pre><code># project/services.py\nclass UserService:\n    def __init__(\n        self,\n        db: IDatabaseSession,\n        cache: ICacheService,\n        logger: ILogger\n    ):\n        self.db = db\n        self.cache = cache\n        self.logger = logger\n\n    def get_user(self, id: int) -&gt; dict:\n        self.logger.info(f\"Getting user {id}\")\n        # Use self.db, self.cache, etc.\n        return {\"id\": id}\n\ncontainer.add_scoped(IUserService, UserService)\n</code></pre> <p>You can mix FastIoC dependencies with FastAPI features:</p> <pre><code>from fastapi import Header, Cookie\n\nclass AuthenticatedService:\n    def __init__(\n        self,\n        # FastIoC dependencies\n        db: IDatabaseSession,\n        auth: IAuthService,\n\n        # FastAPI features work too!\n        authorization: Annotated[str, Header()],\n        session_id: Annotated[str, Cookie()]\n    ):\n        self.db = db\n        self.auth = auth\n        self.token = authorization\n        self.session = session_id\n</code></pre>"},{"location":"nested/#method-2-resolution-in-class-type-hints","title":"Method 2: Resolution in Class Type Hints \u26a1\ufe0f","text":"<p>This is FastIoC's unique feature! You can declare dependencies as class-level type hints, and they'll be automatically resolved and available in all methods via <code>self</code>:</p> <pre><code># project/services.py\nclass OrderService:\n    # Declare dependencies as class attributes (type hints only, no values!)\n    db: IDatabaseSession\n    payment: IPaymentService\n    notification: INotificationService\n\n    def create_order(self, user_id: int, amount: float):\n        # All dependencies available via self!\n        order = self.db.create_order(user_id, amount)\n        self.payment.process(order)\n        self.notification.send(order)\n        return order\n\n    def cancel_order(self, order_id: int):\n        # Same dependencies available here too!\n        order = self.db.get_order(order_id)\n        self.payment.refund(order)\n        self.notification.send_cancellation(order)\n\ncontainer.add_scoped(IOrderService, OrderService)\n</code></pre> <p>How it works: - Dependency is resolved once per class instance - Available in all methods via <code>self.attribute_name</code> - No <code>__init__</code> needed for simple cases!</p> <p>Important Notes:</p> <ol> <li> <p>Attribute must not have a value - If it has a default value, FastIoC ignores it:    <pre><code>class MyService:\n    db: IDatabaseSession = None  # \u274c FastIoC ignores this (has default value)\n    cache: ICacheService          # \u2705 FastIoC injects this\n</code></pre></p> </li> <li> <p><code>__init__</code> parameter takes precedence - If <code>__init__</code> has a parameter with the same name, FastIoC ignores the class hint:    <pre><code>class MyService:\n    db: IDatabaseSession  # This will be ignored\n\n    def __init__(self, db: CustomDB):\n        # You're handling 'db' yourself\n        self.db = db\n</code></pre></p> </li> <li> <p>Works with FastAPI features - You can use FastAPI's special annotations:    <pre><code>class APIService:\n    # FastIoC dependencies\n    db: IDatabaseSession\n\n    # FastAPI features\n    request: Request\n    background: BackgroundTasks\n    user_id: Annotated[int, Cookie()]\n    api_key: Annotated[str, Header()]\n\n    def process(self):\n        # All available via self!\n        cookies = self.request.cookies\n        self.background.add_task(log_action)\n        data = self.db.query(self.user_id)\n        return data\n</code></pre></p> </li> </ol> <p>Supported FastAPI types: <code>Request</code>, <code>Response</code>, <code>BackgroundTasks</code>, <code>WebSocket</code>, <code>UploadFile</code>, <code>SecurityScopes</code>, and annotations like <code>Query</code>, <code>Body</code>, <code>Path</code>, <code>File</code>, <code>Form</code>, <code>Cookie</code>, <code>Header</code>, <code>Security</code>, or even <code>Depends()</code>.</p> <ol> <li>Lifetime consideration - The dependency is resolved once per class instance, not per method call. Watch your lifetime configurations carefully.</li> </ol>"},{"location":"nested/#real-world-example","title":"Real-World Example","text":"<pre><code># project/interfaces.py\nfrom typing import Protocol\n\nclass IDatabaseSession(Protocol):\n    def query(self, sql: str): ...\n\nclass IEmailService(Protocol):\n    def send(self, to: str, message: str): ...\n\nclass ILogger(Protocol):\n    def info(self, message: str): ...\n</code></pre> <pre><code># project/services.py\nfrom fastapi import BackgroundTasks, Request\n\nclass UserManagementService:\n    # Dependencies as class attributes\n    db: IDatabaseSession\n    email: IEmailService\n    logger: ILogger\n    background: BackgroundTasks\n    request: Request\n\n    def create_user(self, username: str, email_addr: str):\n        # All dependencies available!\n        self.logger.info(f\"Creating user: {username}\")\n\n        user = self.db.query(f\"INSERT INTO users ...\")\n\n        # Queue email in background\n        self.background.add_task(\n            self.email.send,\n            email_addr,\n            \"Welcome!\"\n        )\n\n        # Access request info\n        ip = self.request.client.host\n        self.logger.info(f\"User created from IP: {ip}\")\n\n        return user\n</code></pre> <pre><code># project/container.py\ncontainer.add_scoped(IDatabaseSession, DatabaseSession)\ncontainer.add_scoped(IEmailService, EmailService)\ncontainer.add_singleton(ILogger, Logger)\ncontainer.add_scoped(IUserManagementService, UserManagementService)\n</code></pre> <p>No <code>__init__</code> needed - all dependencies are automatically available!</p>"},{"location":"nested/#advanced-instance-based-dependencies","title":"Advanced: Instance-Based Dependencies","text":"<p>Callable Instance Dependency Resolution</p> <p>When using callable class instances (classes with <code>__call__</code>), only the <code>__call__</code> method parameters are injectified, not <code>__init__</code> or class-level type hints.</p> <p>This is because the actual dependency is the instance, not the class itself.</p> <pre><code>class RequestTracker:\n    db: IDatabaseSession  # \u274c NOT injected (instance-based dependency)\n\n    def __init__(self):\n        # \u274c Parameters here are NOT injected\n        self.count = 0\n\n    def __call__(self, db: IDatabaseSession) -&gt; dict:\n        # \u2705 Parameters here ARE injected\n        self.count += 1\n        return {\"count\": self.count, \"db\": db}\n\ntracker = RequestTracker()  # Create instance\ncontainer.add_scoped(TrackerData, tracker)  # Register instance\n</code></pre>"},{"location":"nested/#lifetime-rules-in-dependency-chains","title":"Lifetime Rules in Dependency Chains","text":"<p>When dependencies depend on other dependencies, their lifetimes must follow specific rules:</p>"},{"location":"nested/#transient-can-depend-on-anything","title":"Transient \u2705 Can Depend on Anything","text":"<p>Transient dependencies can depend on any lifetime:</p> <pre><code>class TransientService:\n    def __init__(\n        self,\n        singleton: ISingletonService,    # \u2705 OK\n        scoped: IScopedService,           # \u2705 OK\n        transient: IAnotherTransient      # \u2705 OK\n    ):\n        pass\n\ncontainer.add_transient(ITransientService, TransientService)\n</code></pre>"},{"location":"nested/#scoped-can-depend-on-anything-with-caution","title":"Scoped \u2705 Can Depend on Anything (with caution)","text":"<p>Scoped dependencies can technically depend on any lifetime, but be careful with transient:</p> <pre><code>class ScopedService:\n    def __init__(\n        self,\n        singleton: ISingletonService,    # \u2705 OK\n        scoped: IAnotherScoped,          # \u2705 OK\n        transient: ITransientService     # \u26a0\ufe0f Works, but watch behavior!\n    ):\n        pass\n</code></pre> <p>When depending on transient: The transient dependency is created once when the scoped dependency is created, then reused for the request duration. It effectively becomes scoped. Make sure this is what you want!</p>"},{"location":"nested/#singleton-can-only-depend-on-singleton","title":"Singleton \u26a0\ufe0f Can ONLY Depend on Singleton","text":"<p>Singletons cannot depend on scoped or transient dependencies:</p> <pre><code>class SingletonService:\n    def __init__(\n        self,\n        singleton: IAnotherSingleton,    # \u2705 OK\n        scoped: IScopedService           # \u274c ERROR!\n    ):\n        pass\n\ncontainer.add_singleton(ISingletonService, SingletonService)\n# Raises SingletonLifetimeViolationError!\n</code></pre> <p>Why? A singleton lives for the entire application lifetime. If it depended on a scoped (per-request) or transient dependency, the singleton would capture the first instance and keep it forever, violating the intended lifetime.</p>"},{"location":"nested/#singletonlifetimeviolationerror","title":"SingletonLifetimeViolationError","text":"<p>When you try to register a singleton that depends on a non-singleton, FastIoC raises <code>SingletonLifetimeViolationError</code>:</p> <pre><code>from fastioc.errors import SingletonLifetimeViolationError\n\nclass UserService:\n    def __init__(self, db: IDatabaseSession):  # Scoped!\n        self.db = db\n\ntry:\n    container.add_singleton(IUserService, UserService)\nexcept SingletonLifetimeViolationError as e:\n    print(f\"Cannot register singleton: {e}\")\n    # Error: Singleton 'IUserService' cannot depend on scoped 'IDatabaseSession'\n</code></pre> <p>Solution: Register the dependency with a compatible lifetime:</p> <pre><code># Option 1: Make the service scoped too\ncontainer.add_scoped(IUserService, UserService)  # \u2705 OK\n\n# Option 2: Make the database singleton (if appropriate)\ncontainer.add_singleton(IDatabaseSession, DatabasePool)  # \u2705 OK\n</code></pre>"},{"location":"nested/#advanced-scoped-proxy-pattern","title":"Advanced: Scoped Proxy Pattern","text":"<p>Using Other Lifetimes for Scoped Proxy Behavior</p> <p>If you need a singleton that can access scoped dependencies, use callable instance dependencies with scoped lifetime.</p> <p>This creates a \"scoped proxy\" pattern (similar to Spring Boot): - The instance persists (singleton-like) - <code>__call__</code> is invoked per request (can access request context) - Can depend on scoped dependencies</p> <pre><code>class UserContextProxy:\n    def __init__(self):\n        self.request_count = 0  # Persists\n\n    def __call__(self, db: IDatabaseSession) -&gt; dict:  # Scoped!\n        self.request_count += 1\n        return {\n            \"count\": self.request_count,\n            \"user\": db.get_current_user()\n        }\n\nproxy = UserContextProxy()\ncontainer.add_scoped(UserContext, proxy)\n</code></pre> <p>See Callable Class Instances with Lifetimes for details.</p>"},{"location":"nested/#dependency-chain-example","title":"Dependency Chain Example","text":"<p>Here's a complete example showing a multi-level dependency chain:</p> <pre><code># Level 1: Database connection (singleton)\nclass ConnectionPool:\n    def get_connection(self):\n        return create_connection()\n\ncontainer.add_singleton(IConnectionPool, ConnectionPool)\n\n# Level 2: Database session (scoped, depends on pool)\nclass DatabaseSession:\n    pool: IConnectionPool  # Resolved via class hint!\n\n    def query(self, sql: str):\n        conn = self.pool.get_connection()\n        return conn.execute(sql)\n\ncontainer.add_scoped(IDatabaseSession, DatabaseSession)\n\n# Level 3: Repository (scoped, depends on session)\nclass UserRepository:\n    db: IDatabaseSession\n\n    def get_user(self, id: int):\n        return self.db.query(f\"SELECT * FROM users WHERE id = {id}\")\n\ncontainer.add_scoped(IUserRepository, UserRepository)\n\n# Level 4: Service (scoped, depends on repository)\nclass UserService:\n    repo: IUserRepository\n    logger: ILogger\n\n    def get_user_with_logging(self, id: int):\n        self.logger.info(f\"Fetching user {id}\")\n        return self.repo.get_user(id)\n\ncontainer.add_singleton(ILogger, Logger)\ncontainer.add_scoped(IUserService, UserService)\n</code></pre> <pre><code>@app.get('/user/{user_id}')\ndef get_user(user_id: int, service: IUserService):\n    # Entire chain is resolved automatically:\n    # UserService -&gt; UserRepository -&gt; DatabaseSession -&gt; ConnectionPool + Logger\n    return service.get_user_with_logging(user_id)\n</code></pre>"},{"location":"nested/#related-topics","title":"Related Topics","text":"<ul> <li>Dependency Lifetimes - Understand singleton, scoped, and transient lifetimes</li> <li>Callable Class Instances - Advanced pattern for stateful dependencies</li> <li>SingletonLifetimeViolationError - API reference for lifetime violation errors</li> </ul>"},{"location":"nested/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Dependency Overrides - replacing dependencies for testing</li> <li>Explore Dispose - cleaning up singleton resources</li> <li>Understand Testing - testing with dependency injection</li> </ul>"},{"location":"override/","title":"Dependency Overrides","text":"<p>FastIoC provides full compatibility with FastAPI's dependency override system, making it easy to replace dependencies during testing or other scenarios.</p>"},{"location":"override/#the-containeroverride-method","title":"The <code>Container.override()</code> Method","text":"<p>The <code>Container.override()</code> method generates an updated dictionary suitable for FastAPI's <code>app.dependency_overrides</code>. It supports two ways to override dependencies:</p> <ol> <li>A dictionary of explicit dependency overrides</li> <li>An optional mock container with alternative implementations</li> </ol>"},{"location":"override/#basic-usage-with-dictionary","title":"Basic Usage with Dictionary","text":"<p>You can override registered dependencies by passing a dictionary where keys are protocol types and values are the replacement implementations:</p> <pre><code>from fastapi import FastAPI, Depends\nfrom fastioc import Container\n\napp = FastAPI()\ncontainer = Container()\n\n# Register original dependencies\ncontainer.add_scoped(INumberService, NumberService)\ncontainer.injectify(app)\n\n# Create overrides\noverrides = {\n    INumberService: MockNumberService,\n    get_function_number: get_mock_function_number\n}\n\n# Apply overrides\napp.dependency_overrides = container.override(overrides)\n</code></pre> <p>Important: When overriding container-registered dependencies, use the exact protocol type as the key (e.g., <code>INumberService</code>), not <code>Annotated[SomeType, INumberService]</code>.</p>"},{"location":"override/#mixing-fastapi-and-fastioc-dependencies","title":"Mixing FastAPI and FastIoC Dependencies","text":"<p>One powerful feature of <code>Container.override()</code> is that it seamlessly combines FastAPI's native dependencies with FastIoC dependencies. Keys that are not registered in the container remain unchanged, allowing you to mix both systems:</p> <pre><code>overrides = {\n    IService: MockService,           # FastIoC dependency\n    get_user: get_mock_user,         # Regular FastAPI dependency\n    some_function: mock_function     # Another FastAPI dependency\n}\n\napp.dependency_overrides = container.override(overrides)\n</code></pre>"},{"location":"override/#using-a-mock-container","title":"Using a Mock Container","text":"<p>For more complex testing scenarios, you can create a separate container with mock implementations and pass it to the <code>override()</code> method:</p> <pre><code># Create a test container with mock implementations\ntest_container = Container()\ntest_container.add_scoped(IGlobalService, MockGlobalService)\ntest_container.add_scoped(INumberService, MockNumberService)\n\n# Apply all mock container dependencies as overrides\napp.dependency_overrides = container.override(container=test_container)\n\n# Or combine with explicit overrides\napp.dependency_overrides = container.override(\n    dependencies={get_function: mock_function},\n    container=test_container\n)\n</code></pre>"},{"location":"override/#lifetime-preservation","title":"Lifetime Preservation","text":"<p>\u26a0\ufe0f IMPORTANT: Always use the same lifetime in your mock container as in your main container. Mixing different lifetimes can lead to unexpected behavior and should be avoided in most cases.</p> <p>The override system preserves the original container's lifetime to ensure your tests maintain realistic dependency lifecycles. Simply register your mocks with the same lifetime as the originals:</p> <pre><code># Main container\ncontainer = Container()\ncontainer.add_singleton(IGlobalService, GlobalService)\ncontainer.add_scoped(INumberService, NumberService)\n\n# Test container - use the SAME lifetimes\ntest_container = Container()\ntest_container.add_singleton(IGlobalService, MockGlobalService)  # \u2705 Same: SINGLETON\ntest_container.add_scoped(INumberService, MockNumberService)      # \u2705 Same: SCOPED\n\napp.dependency_overrides = container.override(container=test_container)\n</code></pre> <p>\u26a0\ufe0f Advanced: Lifetime Override Behavior</p> <p>If you must use different lifetimes (not recommended), be aware of these rules:</p> <ol> <li> <p>SCOPED or TRANSIENT in main container: The original lifetime is always preserved, regardless of what is registered in the mock container (except when the mock is SINGLETON).</p> </li> <li> <p>SINGLETON in main container:</p> </li> <li> <p>If the mock container has a different lifetime \u2192 the resulting lifetime will be SCOPED</p> </li> <li> <p>Non-SINGLETON in main container:</p> </li> <li>If the mock container registers it as SINGLETON \u2192 the resulting lifetime will be SINGLETON</li> </ol> <p>Example with mixed lifetimes (not recommended): <pre><code># Main container\ncontainer = Container()\ncontainer.add_singleton(ILifetimeServiceSingleton, LifetimeService)\ncontainer.add_scoped(ILifetimeServiceScoped, LifetimeService)\ncontainer.add_transient(ILifetimeServiceFactory, LifetimeService)\n\n# Test container with DIFFERENT lifetimes\ntest_container = Container()\ntest_container.add_singleton(ILifetimeServiceSingleton, MockLifetimeService)\ntest_container.add_transient(ILifetimeServiceScoped, MockLifetimeService)\ntest_container.add_transient(ILifetimeServiceFactory, MockLifetimeService)\n\n# Apply overrides\napp.dependency_overrides = container.override(container=test_container)\n\n# Resulting lifetimes:\n# - ILifetimeServiceSingleton: SCOPED (singleton \u2192 different lifetime)\n# - ILifetimeServiceScoped: SCOPED (preserved from main)\n# - ILifetimeServiceFactory: TRANSIENT (preserved from main)\n</code></pre></p>"},{"location":"override/#complete-testing-example","title":"Complete Testing Example","text":"<p>Here's a complete example showing how to use <code>Container.override()</code> in tests:</p> <pre><code>from fastapi import FastAPI, Depends\nfrom fastapi.testclient import TestClient\nfrom fastioc import Container\n\n# Original implementations\nclass NumberService:\n    def get_number(self) -&gt; int:\n        return 42\n\nclass GlobalService:\n    def __init__(self):\n        self.value = 100\n\n# Mock implementations\nclass MockNumberService:\n    def get_number(self) -&gt; int:\n        return 999\n\nclass MockGlobalService:\n    def __init__(self):\n        self.value = 888\n\ndef get_function_number() -&gt; int:\n    return 42\n\ndef get_mock_function_number() -&gt; int:\n    return 777\n\n# Setup\napp = FastAPI()\ncontainer = Container()\n\ncontainer.add_scoped(IGlobalService, GlobalService)\ncontainer.add_scoped(INumberService, NumberService)\ncontainer.injectify(app)\n\n# Create test container\ntest_container = Container()\ntest_container.add_scoped(IGlobalService, MockGlobalService)\ntest_container.add_scoped(INumberService, MockNumberService)\n\n# Apply overrides\napp.dependency_overrides = container.override(\n    dependencies={get_function_number: get_mock_function_number},\n    container=test_container\n)\n\n# Test endpoint\n@app.get('/test', dependencies=[IGlobalService])\nasync def endpoint(\n    service: INumberService,\n    number: int = Depends(get_function_number)\n):\n    return {\n        'service': service.get_number(),\n        'number': number\n    }\n\n# Test\nclient = TestClient(app)\nresponse = client.get('/test')\ndata = response.json()\n\nassert data['service'] == 999  # From MockNumberService\nassert data['number'] == 777   # From get_mock_function_number\n</code></pre>"},{"location":"override/#key-takeaways","title":"Key Takeaways","text":"<ul> <li><code>Container.override()</code> provides full compatibility with FastAPI's dependency override system</li> <li>Use exact protocol types (not <code>Annotated</code> types) as dictionary keys</li> <li>Combine FastAPI and FastIoC dependencies seamlessly in the same override dictionary</li> <li>Pass a mock container for complex testing scenarios</li> <li>Original lifetimes are preserved to maintain realistic behavior (with specific exceptions for SINGLETON overrides)</li> <li>Unregistered keys in the override dictionary are left unchanged, enabling flexible mixing of different dependency types</li> </ul>"},{"location":"passive/","title":"Passive Dependencies","text":"<p>Passive dependencies (also known as path operation dependencies) are dependencies that run for every request but don't inject their return value into the endpoint function. They're useful for side effects like logging, authentication checks, or setting up request-scoped state.</p> <p>FastIoC fully supports passive dependencies in endpoints, routers, and applications - just like regular FastAPI dependencies.</p>"},{"location":"passive/#endpoint-passive-dependencies","title":"Endpoint Passive Dependencies","text":"<p>You can add passive dependencies to individual endpoints using the <code>dependencies</code> parameter:</p> <pre><code># main.py\nfrom fastapi import FastAPI, Depends\nfrom project.interfaces import IAuthService, ILogService\nfrom project.container import container\n\napp = FastAPI()\ncontainer.injectify(app)\n\n@app.get(\n    '/protected',\n    dependencies=[IAuthService, ILogService]  # pyright: ignore[reportArgumentType]\n)\ndef protected_endpoint(data: str):\n    # IAuthService and ILogService run before this function\n    # but their return values are not injected here\n    return {\"data\": data}\n</code></pre> <p>Important: Add <code># pyright: ignore[reportArgumentType]</code> at the end of the line (or use your IDE's quick fix to ignore the error). Type checkers expect <code>dependencies</code> to be a list of <code>Depends()</code> objects, but FastIoC automatically converts your registered types to <code>Depends()</code> under the hood.</p> <p>You can also mix FastIoC dependencies with traditional FastAPI dependencies:</p> <pre><code>from fastapi import Depends\n\ndef some_fastapi_dep():\n    print(\"Running FastAPI dependency\")\n\n@app.get(\n    '/mixed',\n    dependencies=[IAuthService, Depends(some_fastapi_dep)]  # pyright: ignore[reportArgumentType]\n)\ndef mixed_endpoint():\n    return {\"status\": \"ok\"}\n</code></pre>"},{"location":"passive/#router-passive-dependencies","title":"Router Passive Dependencies","text":"<p>Apply passive dependencies to all endpoints in a router:</p> <pre><code># project/routers/admin.py\nfrom fastapi import APIRouter, Depends\nfrom project.interfaces import IAdminAuthService, IAuditService\nfrom project.container import container\n\nrouter = APIRouter(\n    prefix=\"/admin\",\n    dependencies=[IAdminAuthService, IAuditService]  # pyright: ignore[reportArgumentType]\n)\n\ncontainer.injectify(router)\n\n@router.get('/users')\ndef list_admin_users():\n    # IAdminAuthService and IAuditService run for every endpoint in this router\n    return {\"users\": []}\n\n@router.get('/settings')\ndef get_admin_settings():\n    # Same dependencies run here too\n    return {\"settings\": {}}\n</code></pre> <p>All endpoints in the router will automatically have these dependencies executed before the endpoint handler.</p>"},{"location":"passive/#application-passive-dependencies","title":"Application Passive Dependencies","text":"<p>Apply passive dependencies to all endpoints in your entire application (also known as Global Dependencies in FastAPI):</p> <pre><code># main.py\nfrom fastapi import FastAPI, Depends\nfrom project.interfaces import IGlobalLogger, IRequestTracker\nfrom project.container import container\n\napp = FastAPI(\n    dependencies=[IGlobalLogger, IRequestTracker]  # pyright: ignore[reportArgumentType]\n)\n\ncontainer.injectify(app)\n\n@app.get('/endpoint1')\ndef endpoint1():\n    # IGlobalLogger and IRequestTracker run here\n    return {\"endpoint\": 1}\n\n@app.get('/endpoint2')\ndef endpoint2():\n    # And here too - for every endpoint\n    return {\"endpoint\": 2}\n</code></pre> <p>Every endpoint in the application will execute these dependencies.</p>"},{"location":"passive/#combining-passive-dependencies","title":"Combining Passive Dependencies","text":"<p>You can combine passive dependencies at different levels - they all stack together:</p> <pre><code># main.py\nfrom fastapi import FastAPI, APIRouter, Depends\nfrom project.interfaces import IGlobalLogger, IAuthService, IRateLimiter\nfrom project.container import container\n\n# Application-level: runs for ALL endpoints\napp = FastAPI(\n    dependencies=[IGlobalLogger]  # pyright: ignore[reportArgumentType]\n)\n\n# Router-level: runs for all endpoints in this router\nadmin_router = APIRouter(\n    prefix=\"/admin\",\n    dependencies=[IAuthService]  # pyright: ignore[reportArgumentType]\n)\n\ncontainer.injectify(app, admin_router)\n\n# Endpoint-level: runs only for this specific endpoint\n@admin_router.get(\n    '/critical',\n    dependencies=[IRateLimiter]  # pyright: ignore[reportArgumentType]\n)\ndef critical_operation():\n    # All three run: IGlobalLogger \ufffd IAuthService \ufffd IRateLimiter\n    return {\"status\": \"executed\"}\n\n@admin_router.get('/normal')\ndef normal_operation():\n    # Only two run: IGlobalLogger \ufffd IAuthService\n    return {\"status\": \"ok\"}\n\napp.include_router(admin_router)\n</code></pre> <p>The dependencies execute in order from broadest to most specific: 1. Application-level dependencies 2. Router-level dependencies 3. Endpoint-level dependencies</p>"},{"location":"passive/#type-checker-warnings","title":"Type Checker Warnings","text":"<p>When using FastIoC dependencies in the <code>dependencies</code> parameter, your IDE or type checker (like Pyright, mypy) will show an error because it expects <code>Depends()</code> objects:</p> <pre><code># Type checker will complain about this:\n@app.get('/endpoint', dependencies=[IUserService])\n#                                    ^^^^^^^^^^^\n# Expected type 'Depends', got 'type[IUserService]'\n</code></pre> <p>Solutions:</p>"},{"location":"passive/#option-1-inline-comment-recommended","title":"Option 1: Inline Comment (Recommended)","text":"<pre><code>@app.get('/endpoint', dependencies=[IUserService])  # pyright: ignore[reportArgumentType]\n</code></pre>"},{"location":"passive/#option-2-type-ignore-comment","title":"Option 2: Type Ignore Comment","text":"<pre><code>@app.get('/endpoint', dependencies=[IUserService])  # type: ignore\n</code></pre>"},{"location":"passive/#option-3-ide-quick-fix","title":"Option 3: IDE Quick Fix","text":"<p>Most IDEs (VS Code, PyCharm) offer quick fixes to suppress these warnings. Use the IDE's suggestion feature to add the appropriate ignore comment.</p> <p>Why this happens: FastIoC intercepts these dependencies and converts them to <code>Depends()</code> automatically during the injectify process. The type checker doesn't know about this runtime transformation, so it sees a type mismatch.</p>"},{"location":"passive/#use-cases-for-passive-dependencies","title":"Use Cases for Passive Dependencies","text":"<p>Passive dependencies are ideal for:</p> <ul> <li>Authentication/Authorization - Validate tokens, check permissions</li> <li>Logging/Monitoring - Log requests, track metrics</li> <li>Rate Limiting - Throttle requests per user/IP</li> <li>Request Validation - Check headers, validate API keys</li> <li>Database Transactions - Set up transaction context</li> <li>Caching - Check cache validity</li> <li>Feature Flags - Enable/disable features per request</li> <li>Audit Trails - Record who accessed what</li> </ul> <p>Since passive dependencies don't inject their return values, they're perfect for side effects that don't need to pass data to the endpoint.</p>"},{"location":"passive/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Dependency Lifetimes - singleton, scoped, and transient behaviors</li> <li>Explore Nested Dependencies - automatic resolution of dependency chains</li> <li>Understand Testing - how to test applications with dependency injection</li> </ul>"},{"location":"register/","title":"Dependency Registration","text":"<p>Registration is the process of telling the container which implementation to provide when a specific interface (protocol) is requested. FastIoC makes this incredibly simple with zero boilerplate.</p>"},{"location":"register/#creating-a-container","title":"Creating a Container","text":"<p>First, create a <code>Container</code> instance:</p> <pre><code>from fastioc import Container\n\ncontainer = Container()\n</code></pre> <p>That's it! Your container is ready to register dependencies.</p>"},{"location":"register/#understanding-interfaces","title":"Understanding Interfaces","text":"<p>In FastIoC, any type can be used as an interface - whether it's a Protocol, an abstract class, a regular class, or even a custom marker type. However, Protocols are recommended for class-based dependencies as they provide better type safety, editor support, and enable true interface-based programming following the Dependency Inversion Principle:</p> <pre><code>from typing import Protocol\n\nclass IService(Protocol):\n    \"\"\"This is your interface - what you'll request in endpoints\"\"\"\n\n    def get_data(self) -&gt; str: ...\n</code></pre>"},{"location":"register/#registering-dependencies","title":"Registering Dependencies","text":"<p>FastIoC supports everything that can be a dependency in FastAPI - classes, functions, generators, async generators, callable objects, and more. All of them work seamlessly with both sync and async implementations - FastAPI handles the execution automatically.</p> <p>Here are the most common patterns:</p>"},{"location":"register/#class-based-dependencies","title":"Class-Based Dependencies","text":"<p>The most common pattern for stateful services:</p> <pre><code>from typing import Protocol\n\n# 1. Define your interface\nclass IUserService(Protocol):\n    def get_user(self, id: int) -&gt; dict: ...\n    async def get_user_async(self, id: int) -&gt; dict: ...\n\n# 2. Implement the concrete class\nclass UserService(IUserService):\n    def __init__(self):\n        self.db_connection = \"postgresql://...\"\n\n    def get_user(self, id: int) -&gt; dict:\n        return {\"id\": id, \"name\": \"John Doe\"}\n\n    async def get_user_async(self, id: int) -&gt; dict:\n        # You can mix sync and async methods in the same class\n        return {\"id\": id, \"name\": \"Jane Doe\"}\n\n# 3. Register with the container\ncontainer.add_scoped(IUserService, UserService)\n</code></pre> <p>Using the Same Class as Interface:</p> <p>For simpler projects, you can use the class itself as both the interface and implementation (similar to NestJS):</p> <pre><code>class UserService:\n    def get_user(self, id: int) -&gt; dict:\n        return {\"id\": id, \"name\": \"John Doe\"}\n\n# Register the class to itself\ncontainer.add_scoped(UserService, UserService)\n</code></pre> <p>However, for larger projects, using separate Protocols as interfaces is considered best practice as it: - Follows the Dependency Inversion Principle (depend on abstractions, not concretions) - Makes your code more testable (easy to mock interfaces) - Provides better separation of concerns - Enables swapping implementations without changing dependent code</p>"},{"location":"register/#function-based-dependencies","title":"Function-Based Dependencies","text":"<p>Perfect for simple, stateless operations or direct value providers:</p> <pre><code># 1. Define a marker type for your dependency\nclass UserId(int):\n    \"\"\"Custom type to identify this dependency\"\"\"\n    ...\n\n# 2. Create your function\ndef get_user_id() -&gt; int:\n    return 42\n\n# 3. Register with the container\ncontainer.add_scoped(UserId, get_user_id)\n</code></pre> <p>Async Example:</p> <pre><code>class ApiKey(str):\n    ...\n\nasync def fetch_api_key() -&gt; str:\n    # FastAPI handles async automatically\n    return \"secret-key-123\"\n\ncontainer.add_scoped(ApiKey, fetch_api_key)\n</code></pre>"},{"location":"register/#generator-based-dependencies","title":"Generator-Based Dependencies","text":"<p>Ideal when you need setup and teardown logic (like managing database connections or file handles):</p> <pre><code>from typing import Generator\n\nclass DatabaseConnection(object):\n    \"\"\"Marker type for DB connection\"\"\"\n    ...\n\ndef get_db_connection() -&gt; Generator[object, None, None]:\n    # Setup: acquire resource\n    connection = create_connection()\n    print(\"Connection opened\")\n\n    try:\n        yield connection  # Provide the dependency\n    finally:\n        # Teardown: cleanup resource\n        connection.close()\n        print(\"Connection closed\")\n\ncontainer.add_scoped(DatabaseConnection, get_db_connection)\n</code></pre> <p>Async Generator Example:</p> <pre><code>from typing import AsyncGenerator\n\nclass AsyncDbConnection(object):\n    ...\n\nasync def get_async_db() -&gt; AsyncGenerator[object, None]:\n    # Setup\n    db = await connect_async()\n\n    try:\n        yield db\n    finally:\n        # Cleanup\n        await db.close()\n\ncontainer.add_scoped(AsyncDbConnection, get_async_db)\n</code></pre>"},{"location":"register/#callable-class-instances-advanced","title":"Callable Class Instances (Advanced)","text":"<p>For more advanced use cases, you can use callable class instances as dependencies. This pattern is useful when you need to configure a dependency with parameters or maintain state across multiple calls:</p> <pre><code># 1. Define a callable class (with __call__ method)\nclass DatabaseConnectionFactory:\n    def __init__(self, connection_string: str):\n        self.connection_string = connection_string\n        self.call_count = 0\n\n    def __call__(self) -&gt; dict:\n        self.call_count += 1\n        return {\n            \"connection\": self.connection_string,\n            \"call_count\": self.call_count\n        }\n\n# 2. Create an instance with configuration\ndb_factory = DatabaseConnectionFactory(\"postgresql://localhost/mydb\")\n\n# 3. Define a marker type\nclass DbConfig(dict):\n    ...\n\n# 4. Register the instance (not the class!)\ncontainer.add_scoped(DbConfig, db_factory)\n</code></pre> <p>When to use: - When you need to pass configuration to the dependency at registration time - When you need to maintain state across dependency resolutions - When you want more control over the dependency creation process</p> <p>Note: You're registering the instance (the callable object), not the class itself. Each time the dependency is resolved, the <code>__call__</code> method is invoked.</p> <pre><code>@app.get('/db-info')\ndef get_db_info(config1: DbConfig, config2: DbConfig):\n    # First call: {\"connection\": \"postgresql://...\", \"call_count\": 1}\n    # Second call: {\"connection\": \"postgresql://...\", \"call_count\": 2}\n    # The instance's state is maintained!\n    return {\"config1\": config1, \"config2\": config2}\n</code></pre> <p>This pattern gives you the flexibility of functions with the state management of classes.</p>"},{"location":"register/#registration-methods","title":"Registration Methods","text":"<p>FastIoC provides three registration methods that control dependency lifetimes:</p> <pre><code>container.add_singleton(IService, ServiceImpl)   # One instance per application\ncontainer.add_scoped(IService, ServiceImpl)      # One instance per request\ncontainer.add_transient(IService, ServiceImpl)   # New instance every time\n</code></pre> <p>We'll explore these lifetimes in detail in the Dependency Lifetimes chapter.</p>"},{"location":"register/#re-registering-dependencies","title":"Re-registering Dependencies","text":"<p>If you register multiple implementations for the same interface, the last registration always replaces previous ones:</p> <pre><code># First registration\ncontainer.add_scoped(IUserService, UserServiceV1)\n\n# Second registration - replaces the first one\ncontainer.add_scoped(IUserService, UserServiceV2)  # This is what will be used\n\n# Third registration - replaces the second one\ncontainer.add_scoped(IUserService, UserServiceV3)  # This is what will actually be injected\n</code></pre> <p>When a dependency is re-registered: - The previous implementation is completely forgotten - Only the last registered implementation is used - No warning or error is raised</p> <p>When to use this:</p> <p>This behavior is mainly useful when you accidentally register the same interface twice, or when you intentionally want to replace a registration during initial setup.</p> <p>When NOT to use this:</p> <p>\u274c For testing/mocking - Use Dependency Overrides instead (proper way to mock for tests)</p> <p>\u274c For environment-specific configs - Use Dependency Overrides instead (proper way to handle dev/prod)</p> <p>Re-registration works, but dependency overrides are the recommended best practice for replacing implementations in different contexts (testing, environments, etc.).</p>"},{"location":"register/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Dependency Resolution - how to access registered dependencies</li> <li>Understand Dependency Lifetimes - singleton, scoped, and transient behaviors</li> <li>Explore Nested Dependencies - automatic resolution of dependency chains</li> </ul>"},{"location":"resolve/","title":"Dependency Resolution","text":"<p>Once you've registered your dependencies, you can resolve and use them in your FastAPI endpoints. FastIoC makes this incredibly simple - just add type hints to your endpoint parameters, and the container automatically injects the registered implementations.</p>"},{"location":"resolve/#simple-resolution","title":"Simple Resolution","text":"<p>The most straightforward way to resolve dependencies is by type-hinting your endpoint parameters with the registered interface:</p> <pre><code># main.py\nfrom fastapi import FastAPI\nfrom project.interfaces import IUserService\n\napp = FastAPI()\ncontainer.injectify(app)\n\n@app.get('/user/{user_id}')\ndef get_user_endpoint(user_id: int, service: IUserService) -&gt; dict:\n    # service is automatically injected with the registered implementation\n    return service.get_user(user_id)\n</code></pre> <pre><code># project/interfaces.py\nfrom typing import Protocol\n\nclass IUserService(Protocol):\n    def get_user(self, id: int) -&gt; dict: ...\n</code></pre> <p>That's it! No <code>Depends()</code> needed. FastIoC automatically recognizes that <code>IUserService</code> is registered and injects it.</p> <p>Dependency Not Working?</p> <p>If your endpoint returns 422 Unprocessable Entity errors, it likely means the dependency wasn't registered in the container. See Unregistered Dependencies for troubleshooting.</p>"},{"location":"resolve/#annotated-resolution","title":"Annotated Resolution","text":"<p>For non-class dependencies (like functions or custom marker types), you can use Python's <code>Annotated</code> type for clearer intent:</p> <pre><code># main.py\nfrom typing import Annotated\nfrom project.interfaces import IUserService\nfrom project.dependencies import UserId, ApiKey\n\n@app.get('/profile')\ndef get_profile(\n    user_id: Annotated[int, UserId],\n    api_key: Annotated[str, ApiKey]\n) -&gt; dict:\n    return {\n        \"user_id\": user_id,\n        \"authenticated\": True\n    }\n</code></pre> <pre><code># project/dependencies.py\n# Marker types for function-based dependencies\nclass UserId(int): ...\nclass ApiKey(str): ...\n</code></pre> <p>Why use Annotated?</p> <ul> <li>Makes the dependency source explicit and clear</li> <li>Works seamlessly with any dependency type</li> <li>Provides better IDE support and documentation</li> <li>Can also be used with class-based dependencies if preferred</li> </ul> <pre><code># This also works for classes\n@app.get('/data')\ndef get_data(service: Annotated[IUserService, IUserService]) -&gt; dict:\n    return service.get_user(1)\n</code></pre>"},{"location":"resolve/#mixing-with-fastapi-features","title":"Mixing with FastAPI Features","text":"<p>FastIoC is 100% compatible with FastAPI's native features. You can freely mix registered dependencies with query parameters, path parameters, request bodies, headers, cookies, and traditional <code>Depends()</code>:</p> <pre><code># project/routers/items.py\nfrom fastapi import APIRouter, Depends, Header, Cookie\nfrom typing import Annotated\nfrom project.interfaces import IUserService\nfrom project.dependencies import UserId\n\nrouter = APIRouter()\n\ndef get_request_id() -&gt; str:\n    \"\"\"A regular FastAPI dependency (not registered in container)\"\"\"\n    return \"req-12345\"\n\n@router.get('/items/{item_id}')\nasync def get_item(\n    # Path parameter\n    item_id: int,\n\n    # Query parameters\n    q: str,\n    page_size: int = 10,\n\n    # FastIoC registered dependency (simple)\n    service: IUserService,\n\n    # FastIoC registered dependency (annotated)\n    user_id: Annotated[int, UserId],\n\n    # Traditional FastAPI dependency\n    request_id: str = Depends(get_request_id),\n\n    # Headers and cookies\n    authorization: Annotated[str, Header()],\n    session_token: Annotated[str, Cookie()]\n) -&gt; dict:\n    return {\n        \"item_id\": item_id,\n        \"query\": q,\n        \"page_size\": page_size,\n        \"user\": service.get_user(user_id),\n        \"request_id\": request_id,\n        \"auth\": authorization,\n        \"session\": session_token\n    }\n</code></pre> <p>Everything works together seamlessly!</p> <p>&lt;!-- ## \u26a0\ufe0f Important: Parameter Ordering</p> <p>Since FastIoC dependencies are converted to FastAPI's <code>Depends()</code> under the hood, you need to follow Python's parameter ordering rules:</p> <pre><code>from typing import Annotated\nfrom project.interfaces import IUserService\nfrom project.dependencies import UserId\n\n@app.get('/example')\ndef good_example(\n    # \u2705 CORRECT: Simple parameters first\n    item_id: int,\n    q: str,\n    page: int = 1,\n\n    # Then dependencies (they have default values under the hood)\n    service: IUserService,\n    user_id: Annotated[int, UserId]\n) -&gt; dict:\n    return {\"status\": \"ok\"}\n\n@app.get('/example')\ndef bad_example(\n    # \u274c WRONG: Dependencies before simple required parameters\n    service: IUserService,\n    user_id: Annotated[int, UserId],\n\n    # This will cause: \"non-default argument follows default argument\"\n    item_id: int,\n    q: str\n) -&gt; dict:\n    return {\"status\": \"error\"}\n</code></pre> <p>The rule: Place required parameters (path params, required query params) before injected dependencies.</p> <p>This is because under the hood, FastIoC transforms: <pre><code>service: IUserService\n</code></pre> Into: <pre><code>service: IUserService = Depends(registered_service)\n``` --&gt;\n\n## Async Endpoints\n\nBoth sync and async endpoints work identically:\n\n```python\n# project/routers/users.py\nfrom project.interfaces import IUserService\n\n@router.get('/sync')\ndef sync_endpoint(service: IUserService) -&gt; dict:\n    return service.get_user(1)\n\n@router.get('/async')\nasync def async_endpoint(service: IUserService) -&gt; dict:\n    # Same syntax, FastAPI handles execution automatically\n    return service.get_user(1)\n</code></pre></p> <p>Whether your dependency implementation is sync or async, FastAPI automatically handles the execution.</p>"},{"location":"resolve/#next-steps","title":"Next Steps","text":"<ul> <li>Understand Passive Dependencies - using dependencies in route decorators</li> <li>Learn about Dependency Lifetimes - singleton, scoped, and transient behaviors</li> <li>Explore Nested Dependencies - automatic resolution of dependency chains</li> </ul>"},{"location":"scale/","title":"Project Structure at Scale","text":"<p>As your FastAPI application grows, organizing your code becomes crucial for maintainability, testability, and team collaboration. This guide presents a Clean Architecture approach using FastIoC and APIController to structure large-scale applications.</p>"},{"location":"scale/#recommended-project-structure","title":"Recommended Project Structure","text":"<pre><code>project/\n\u251c\u2500\u2500 app/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 main.py               # FastAPI app &amp; startup\n\u2502   \u2514\u2500\u2500 container.py          # Container &amp; dependency registrations\n\u2502\n\u251c\u2500\u2500 core/                     # Domain layer (business logic)\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 entities/             # Domain models\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 user.py\n\u2502   \u2502   \u2514\u2500\u2500 product.py\n\u2502   \u2502\n\u2502   \u2514\u2500\u2500 interfaces/           # Abstract protocols\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u251c\u2500\u2500 repositories.py\n\u2502       \u2514\u2500\u2500 services.py\n\u2502\n\u251c\u2500\u2500 services/                 # Application services\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 user_service.py\n\u2502   \u251c\u2500\u2500 auth_service.py\n\u2502   \u2514\u2500\u2500 email_service.py\n\u2502\n\u251c\u2500\u2500 infrastructure/           # External dependencies\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 database/\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u2514\u2500\u2500 connection.py\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 repositories/\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 user_repository.py\n\u2502   \u2502   \u2514\u2500\u2500 product_repository.py\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 external/\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u2514\u2500\u2500 email_client.py\n\u2502   \u2502\n\u2502   \u2514\u2500\u2500 config/\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u2514\u2500\u2500 settings.py\n\u2502\n\u251c\u2500\u2500 controllers/              # API Controllers\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 user_controller.py\n\u2502   \u251c\u2500\u2500 product_controller.py\n\u2502   \u2514\u2500\u2500 auth_controller.py\n\u2502\n\u251c\u2500\u2500 tests/\n\u2502   \u251c\u2500\u2500 unit/\n\u2502   \u251c\u2500\u2500 integration/\n\u2502   \u2514\u2500\u2500 conftest.py\n\u2502\n\u2514\u2500\u2500 requirements.txt\n</code></pre>"},{"location":"scale/#architecture-layers","title":"Architecture Layers","text":""},{"location":"scale/#1-core-layer-core","title":"1. Core Layer (<code>core/</code>)","text":"<p>The innermost layer containing your business domain. It has no dependencies on outer layers.</p> <p><code>core/entities/user.py</code> - Domain models: <pre><code>from pydantic import BaseModel\nfrom datetime import datetime\n\nclass User(BaseModel):\n    id: int\n    email: str\n    username: str\n    is_active: bool\n    created_at: datetime\n\nclass UserCreate(BaseModel):\n    email: str\n    username: str\n    password: str\n\nclass UserUpdate(BaseModel):\n    email: str | None = None\n    username: str | None = None\n    is_active: bool | None = None\n</code></pre></p> <p><code>core/interfaces/repositories.py</code> - Repository protocols: <pre><code>from typing import Protocol, List, Optional\nfrom app.core.entities.user import User, UserCreate, UserUpdate\n\nclass IUserRepository(Protocol):\n    \"\"\"Protocol for user data access\"\"\"\n\n    def get_by_id(self, user_id: int) -&gt; Optional[User]:\n        ...\n\n    def get_by_email(self, email: str) -&gt; Optional[User]:\n        ...\n\n    def list(self, skip: int = 0, limit: int = 100) -&gt; List[User]:\n        ...\n\n    def create(self, user: UserCreate) -&gt; User:\n        ...\n\n    def update(self, user_id: int, user: UserUpdate) -&gt; Optional[User]:\n        ...\n\n    def delete(self, user_id: int) -&gt; bool:\n        ...\n</code></pre></p> <p><code>core/interfaces/services.py</code> - Service protocols: <pre><code>from typing import Protocol\n\nclass IEmailService(Protocol):\n    \"\"\"Protocol for email operations\"\"\"\n\n    def send_welcome_email(self, email: str, username: str) -&gt; bool:\n        ...\n\n    def send_password_reset(self, email: str, token: str) -&gt; bool:\n        ...\n\nclass IAuthService(Protocol):\n    \"\"\"Protocol for authentication\"\"\"\n\n    def hash_password(self, password: str) -&gt; str:\n        ...\n\n    def verify_password(self, plain: str, hashed: str) -&gt; bool:\n        ...\n\n    def create_access_token(self, user_id: int) -&gt; str:\n        ...\n</code></pre></p>"},{"location":"scale/#2-services-layer-services","title":"2. Services Layer (<code>services/</code>)","text":"<p>Application services implementing business logic using core interfaces.</p> <p>First, let's add a protocol for UserService in <code>core/interfaces/services.py</code>: <pre><code>from typing import Protocol, List, Optional\nfrom app.core.entities.user import User, UserCreate, UserUpdate\n\nclass IUserService(Protocol):\n    \"\"\"Protocol for user business logic\"\"\"\n\n    def get_user(self, user_id: int) -&gt; Optional[User]:\n        ...\n\n    def list_users(self, skip: int = 0, limit: int = 100) -&gt; List[User]:\n        ...\n\n    def create_user(self, user_data: UserCreate) -&gt; User:\n        ...\n\n    def update_user(self, user_id: int, user_data: UserUpdate) -&gt; Optional[User]:\n        ...\n\n    def delete_user(self, user_id: int) -&gt; bool:\n        ...\n\nclass IEmailService(Protocol):\n    \"\"\"Protocol for email operations\"\"\"\n\n    def send_welcome_email(self, email: str, username: str) -&gt; bool:\n        ...\n\n    def send_password_reset(self, email: str, token: str) -&gt; bool:\n        ...\n\nclass IAuthService(Protocol):\n    \"\"\"Protocol for authentication\"\"\"\n\n    def hash_password(self, password: str) -&gt; str:\n        ...\n\n    def verify_password(self, plain: str, hashed: str) -&gt; bool:\n        ...\n\n    def create_access_token(self, user_id: int) -&gt; str:\n        ...\n</code></pre></p> <p><code>services/user_service.py</code>: <pre><code>from typing import List, Optional\nfrom app.core.entities.user import User, UserCreate, UserUpdate\nfrom app.core.interfaces.repositories import IUserRepository\nfrom app.core.interfaces.services import IUserService, IEmailService, IAuthService\n\nclass UserService(IUserService):\n    \"\"\"Business logic for user operations - implements IUserService\"\"\"\n\n    def __init__(\n        self,\n        user_repo: IUserRepository,\n        email_service: IEmailService,\n        auth_service: IAuthService\n    ):\n        self.user_repo = user_repo\n        self.email_service = email_service\n        self.auth_service = auth_service\n\n    def get_user(self, user_id: int) -&gt; Optional[User]:\n        return self.user_repo.get_by_id(user_id)\n\n    def list_users(self, skip: int = 0, limit: int = 100) -&gt; List[User]:\n        return self.user_repo.list(skip, limit)\n\n    def create_user(self, user_data: UserCreate) -&gt; User:\n        # Hash password\n        hashed_password = self.auth_service.hash_password(user_data.password)\n\n        # Create user\n        user = self.user_repo.create(user_data)\n\n        # Send welcome email\n        self.email_service.send_welcome_email(user.email, user.username)\n\n        return user\n\n    def update_user(self, user_id: int, user_data: UserUpdate) -&gt; Optional[User]:\n        return self.user_repo.update(user_id, user_data)\n\n    def delete_user(self, user_id: int) -&gt; bool:\n        return self.user_repo.delete(user_id)\n</code></pre></p> <p><code>services/auth_service.py</code>: <pre><code>import bcrypt\nimport jwt\nfrom datetime import datetime, timedelta\nfrom app.core.interfaces.services import IAuthService\n\nclass AuthService(IAuthService):\n    \"\"\"Authentication service implementation - implements IAuthService\"\"\"\n\n    def __init__(self, secret_key: str = \"your-secret-key\"):\n        self.secret_key = secret_key\n\n    def hash_password(self, password: str) -&gt; str:\n        return bcrypt.hashpw(password.encode(), bcrypt.gensalt()).decode()\n\n    def verify_password(self, plain: str, hashed: str) -&gt; bool:\n        return bcrypt.checkpw(plain.encode(), hashed.encode())\n\n    def create_access_token(self, user_id: int) -&gt; str:\n        payload = {\n            \"user_id\": user_id,\n            \"exp\": datetime.utcnow() + timedelta(hours=24)\n        }\n        return jwt.encode(payload, self.secret_key, algorithm=\"HS256\")\n</code></pre></p>"},{"location":"scale/#3-infrastructure-layer-infrastructure","title":"3. Infrastructure Layer (<code>infrastructure/</code>)","text":"<p>Implementations of external dependencies like databases, APIs, and configuration.</p> <p><code>infrastructure/config/settings.py</code>: <pre><code>from pydantic_settings import BaseSettings\n\nclass Settings(BaseSettings):\n    database_url: str = \"postgresql://localhost/mydb\"\n    secret_key: str = \"your-secret-key\"\n    smtp_host: str = \"smtp.gmail.com\"\n    smtp_port: int = 587\n\n    class Config:\n        env_file = \".env\"\n\ndef get_settings() -&gt; Settings:\n    return Settings()\n</code></pre></p> <p><code>infrastructure/database/connection.py</code>: <pre><code>from sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom app.infrastructure.config.settings import Settings\n\nclass Database:\n    \"\"\"Database connection manager\"\"\"\n\n    def __init__(self, settings: Settings):\n        self.engine = create_engine(settings.database_url)\n        self.SessionLocal = sessionmaker(bind=self.engine)\n\n    def get_session(self) -&gt; Session:\n        return self.SessionLocal()\n\n    def __dispose__(self):\n        \"\"\"Cleanup on shutdown\"\"\"\n        self.engine.dispose()\n</code></pre></p> <p><code>infrastructure/database/repositories/user_repository.py</code>: <pre><code>from typing import List, Optional\nfrom sqlalchemy.orm import Session\nfrom app.core.entities.user import User, UserCreate, UserUpdate\nfrom app.core.interfaces.repositories import IUserRepository\nfrom app.infrastructure.database.connection import Database\n\nclass UserRepository(IUserRepository):\n    \"\"\"User repository implementation - implements IUserRepository\"\"\"\n\n    def __init__(self, db: Database):\n        self.db = db\n\n    def get_by_id(self, user_id: int) -&gt; Optional[User]:\n        with self.db.get_session() as session:\n            # Query database and return User entity\n            result = session.execute(\"SELECT * FROM users WHERE id = :id\", {\"id\": user_id})\n            row = result.fetchone()\n            return User(**row) if row else None\n\n    def get_by_email(self, email: str) -&gt; Optional[User]:\n        with self.db.get_session() as session:\n            result = session.execute(\"SELECT * FROM users WHERE email = :email\", {\"email\": email})\n            row = result.fetchone()\n            return User(**row) if row else None\n\n    def list(self, skip: int = 0, limit: int = 100) -&gt; List[User]:\n        with self.db.get_session() as session:\n            result = session.execute(\n                \"SELECT * FROM users LIMIT :limit OFFSET :skip\",\n                {\"limit\": limit, \"skip\": skip}\n            )\n            return [User(**row) for row in result]\n\n    def create(self, user: UserCreate) -&gt; User:\n        with self.db.get_session() as session:\n            # Insert and return created user\n            result = session.execute(\n                \"INSERT INTO users (email, username) VALUES (:email, :username) RETURNING *\",\n                {\"email\": user.email, \"username\": user.username}\n            )\n            session.commit()\n            return User(**result.fetchone())\n\n    def update(self, user_id: int, user: UserUpdate) -&gt; Optional[User]:\n        # Implementation...\n        pass\n\n    def delete(self, user_id: int) -&gt; bool:\n        # Implementation...\n        pass\n</code></pre></p> <p><code>infrastructure/external/email_client.py</code>: <pre><code>import smtplib\nfrom email.mime.text import MIMEText\nfrom app.core.interfaces.services import IEmailService\nfrom app.infrastructure.config.settings import Settings\n\nclass EmailService(IEmailService):\n    \"\"\"Email service implementation - implements IEmailService\"\"\"\n\n    def __init__(self, settings: Settings):\n        self.settings = settings\n\n    def send_welcome_email(self, email: str, username: str) -&gt; bool:\n        msg = MIMEText(f\"Welcome {username}!\")\n        msg['Subject'] = 'Welcome to Our App'\n        msg['To'] = email\n\n        try:\n            with smtplib.SMTP(self.settings.smtp_host, self.settings.smtp_port) as server:\n                server.send_message(msg)\n            return True\n        except Exception as e:\n            print(f\"Failed to send email: {e}\")\n            return False\n\n    def send_password_reset(self, email: str, token: str) -&gt; bool:\n        # Implementation...\n        pass\n</code></pre></p>"},{"location":"scale/#4-controllers-layer-controllers","title":"4. Controllers Layer (<code>controllers/</code>)","text":"<p>API controllers using APIController for presentation logic.</p> <p><code>controllers/user_controller.py</code>: <pre><code>from fastapi import HTTPException, Query\nfrom typing import Annotated\nfrom fastioc.controller import APIController, get, post, put, delete\nfrom app.core.entities.user import User, UserCreate, UserUpdate\nfrom app.core.interfaces.services import IUserService\n\nclass UserController(APIController):\n    config = {\n        'prefix': '/users',\n        'tags': ['Users']\n        # Container will be set in main.py\n    }\n\n    # Shared dependency - injected into all endpoints\n    user_service: IUserService\n\n    @get('/', response_model=list[User])\n    def list_users(\n        self,\n        skip: int = Query(0, ge=0),\n        limit: int = Query(100, ge=1, le=100)\n    ):\n        \"\"\"List all users with pagination\"\"\"\n        return self.user_service.list_users(skip, limit)\n\n    @get('/{user_id}', response_model=User)\n    def get_user(self, user_id: int):\n        \"\"\"Get a specific user by ID\"\"\"\n        user = self.user_service.get_user(user_id)\n        if not user:\n            raise HTTPException(404, \"User not found\")\n        return user\n\n    @post('/', response_model=User, status_code=201)\n    def create_user(self, user: UserCreate):\n        \"\"\"Create a new user\"\"\"\n        # Check if email already exists\n        existing = self.user_service.user_repo.get_by_email(user.email)\n        if existing:\n            raise HTTPException(400, \"Email already registered\")\n\n        return self.user_service.create_user(user)\n\n    @put('/{user_id}', response_model=User)\n    def update_user(self, user_id: int, user: UserUpdate):\n        \"\"\"Update an existing user\"\"\"\n        updated = self.user_service.update_user(user_id, user)\n        if not updated:\n            raise HTTPException(404, \"User not found\")\n        return updated\n\n    @delete('/{user_id}')\n    def delete_user(self, user_id: int):\n        \"\"\"Delete a user\"\"\"\n        success = self.user_service.delete_user(user_id)\n        if not success:\n            raise HTTPException(404, \"User not found\")\n        return {\"status\": \"deleted\", \"user_id\": user_id}\n</code></pre></p> <p><code>controllers/auth_controller.py</code>: <pre><code>from fastapi import HTTPException\nfrom fastioc.controller import APIController, post\nfrom pydantic import BaseModel\nfrom app.core.interfaces.services import IAuthService\nfrom app.core.interfaces.repositories import IUserRepository\n\nclass LoginRequest(BaseModel):\n    email: str\n    password: str\n\nclass AuthController(APIController):\n    config = {\n        'prefix': '/auth',\n        'tags': ['Authentication']\n    }\n\n    auth_service: IAuthService\n    user_repo: IUserRepository\n\n    @post('/login')\n    def login(self, credentials: LoginRequest):\n        \"\"\"Authenticate user and return access token\"\"\"\n        # Get user\n        user = self.user_repo.get_by_email(credentials.email)\n        if not user:\n            raise HTTPException(401, \"Invalid credentials\")\n\n        # Verify password (simplified - actual implementation would have hashed password)\n        if not self.auth_service.verify_password(credentials.password, \"hashed_password\"):\n            raise HTTPException(401, \"Invalid credentials\")\n\n        # Generate token\n        token = self.auth_service.create_access_token(user.id)\n\n        return {\n            \"access_token\": token,\n            \"token_type\": \"bearer\",\n            \"user\": user\n        }\n</code></pre></p>"},{"location":"scale/#5-container-configuration-containerpy","title":"5. Container Configuration (<code>container.py</code>)","text":"<p>All dependency registrations in a single file:</p> <pre><code>from fastioc import Container\nfrom app.core.interfaces.repositories import IUserRepository\nfrom app.core.interfaces.services import IUserService, IEmailService, IAuthService\nfrom app.services.user_service import UserService\nfrom app.services.auth_service import AuthService\nfrom app.infrastructure.database.connection import Database\nfrom app.infrastructure.database.repositories.user_repository import UserRepository\nfrom app.infrastructure.external.email_client import EmailService\nfrom app.infrastructure.config.settings import Settings, get_settings\n\ndef create_container() -&gt; Container:\n    \"\"\"Create and configure the IoC container with all dependencies\"\"\"\n\n    container = Container()\n\n    # Configuration (Singleton)\n    container.add_singleton(Settings, get_settings)\n\n    # Infrastructure Layer (Singleton - shared resources)\n    container.add_singleton(Database, Database)\n\n    # Repositories (Scoped - per request)\n    container.add_scoped(IUserRepository, UserRepository)\n\n    # External Services (Singleton)\n    container.add_singleton(IEmailService, EmailService)\n    container.add_singleton(IAuthService, AuthService)\n\n    # Application Services (Scoped - per request)\n    container.add_scoped(IUserService, UserService)\n\n    return container\n</code></pre>"},{"location":"scale/#6-application-entry-point-mainpy","title":"6. Application Entry Point (<code>main.py</code>)","text":"<p>FastAPI app initialization with lifespan and controller registration:</p> <pre><code>from contextlib import asynccontextmanager\nfrom fastapi import FastAPI\nfrom app.container import create_container\nfrom app.controllers.user_controller import UserController\nfrom app.controllers.auth_controller import AuthController\n\n# Create container\ncontainer = create_container()\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    \"\"\"Application lifespan - startup and shutdown\"\"\"\n    print(\"=&gt; Application starting...\")\n    yield\n    print(\"=&gt; Application shutting down...\")\n    await container.dispose()\n    print(\"=&gt; Cleanup complete\")\n\n# Create FastAPI app\napp = FastAPI(\n    title=\"My Scalable API\",\n    version=\"1.0.0\",\n    lifespan=lifespan\n)\n\n# Inject container into app for dependency resolution\ncontainer.injectify(app)\n\n# Register all controllers\napp.include_router(UserController.router({'container': container}))\napp.include_router(AuthController.router({'container': container}))\n\n@app.get(\"/\")\ndef root():\n    return {\"message\": \"Welcome to My Scalable API\"}\n\n@app.get(\"/health\")\ndef health():\n    return {\"status\": \"healthy\"}\n</code></pre>"},{"location":"scale/#key-principles","title":"Key Principles","text":""},{"location":"scale/#1-dependency-flow","title":"1. Dependency Flow","text":"<p>Dependencies flow inward: <pre><code>Controllers -&gt; Services -&gt; Repositories -&gt; Database\n     |           |            |\n  (HTTP)    (Business)   (Data Access)\n</code></pre></p> <p>Core layer (domain) has no dependencies on outer layers.</p>"},{"location":"scale/#2-single-container-file","title":"2. Single Container File","text":"<p>All dependency registrations live in <code>container.py</code>. This makes it easy to: - See all your dependencies at a glance - Understand the application structure - Swap implementations for testing - Manage lifetimes consistently</p>"},{"location":"scale/#3-protocol-based-design","title":"3. Protocol-Based Design","text":"<p>Use protocols (interfaces) for loose coupling and have implementations inherit from protocols for type safety: <pre><code># Define protocol in core/interfaces/\nclass IUserRepository(Protocol):\n    def get_by_id(self, user_id: int) -&gt; User: ...\n\n# Implement in infrastructure/ - inherit from protocol\nclass UserRepository(IUserRepository):\n    def get_by_id(self, user_id: int) -&gt; User:\n        # Implementation\n\n# Register protocol \u2192 implementation in container.py\ncontainer.add_scoped(IUserRepository, UserRepository)\n\n# Controllers depend on protocols, not implementations\nclass UserController(APIController):\n    user_repo: IUserRepository  # \u2705 Depend on protocol\n    # user_repo: UserRepository  # \u274c Don't depend on implementation\n</code></pre></p> <p>This approach ensures: - \u2705 Type checkers verify implementations match protocols - \u2705 Easy to swap implementations (e.g., for testing) - \u2705 Clear separation between interface and implementation - \u2705 Controllers/services are decoupled from infrastructure details</p>"},{"location":"scale/#4-organized-by-feature","title":"4. Organized by Feature","text":"<p>For very large applications, consider organizing by feature instead:</p> <pre><code>app/\n\u251c\u2500\u2500 users/\n\u2502   \u251c\u2500\u2500 user_entity.py\n\u2502   \u251c\u2500\u2500 user_repository.py\n\u2502   \u251c\u2500\u2500 user_service.py\n\u2502   \u2514\u2500\u2500 user_controller.py\n\u2502\n\u251c\u2500\u2500 products/\n\u2502   \u251c\u2500\u2500 product_entity.py\n\u2502   \u251c\u2500\u2500 product_repository.py\n\u2502   \u251c\u2500\u2500 product_service.py\n\u2502   \u2514\u2500\u2500 product_controller.py\n\u2502\n\u251c\u2500\u2500 container.py\n\u2514\u2500\u2500 main.py\n</code></pre>"},{"location":"scale/#testing","title":"Testing","text":"<p>With this structure, testing becomes straightforward:</p> <p><code>tests/conftest.py</code>: <pre><code>import pytest\nfrom fastioc import Container\nfrom app.core.interfaces.repositories import IUserRepository\nfrom app.core.interfaces.services import IEmailService\n\n# Mock implementations\nclass MockUserRepository:\n    def get_by_id(self, user_id: int):\n        return {\"id\": user_id, \"email\": \"test@example.com\"}\n\nclass MockEmailService:\n    def send_welcome_email(self, email: str, username: str) -&gt; bool:\n        return True\n\n@pytest.fixture\ndef test_container():\n    \"\"\"Create container with mock dependencies\"\"\"\n    container = Container()\n    container.add_scoped(IUserRepository, MockUserRepository)\n    container.add_singleton(IEmailService, MockEmailService)\n    return container\n</code></pre></p> <p><code>tests/unit/test_user_service.py</code>: <pre><code>from app.services.user_service import UserService\n\ndef test_get_user(test_container):\n    \"\"\"Test user service with mocked dependencies\"\"\"\n    # Get service with injected mocks\n    user_service = test_container.resolve(UserService)\n\n    # Test\n    user = user_service.get_user(1)\n    assert user[\"id\"] == 1\n    assert user[\"email\"] == \"test@example.com\"\n</code></pre></p>"},{"location":"scale/#benefits-of-this-structure","title":"Benefits of This Structure","text":"<ul> <li>Maintainable: Clear separation of concerns</li> <li>Testable: Easy to mock dependencies</li> <li>Scalable: Organized for growth</li> <li>Type-Safe: Protocol-based with full typing</li> <li>Clean: Dependencies flow inward</li> <li>Flexible: Swap implementations easily</li> <li>Documented: Self-documenting structure</li> </ul>"},{"location":"scale/#related-documentation","title":"Related Documentation","text":"<ul> <li>APIController</li> <li>Dependency Lifetimes</li> <li>Nested Dependencies</li> <li>Singleton Cleanup</li> </ul>"},{"location":"reference/container/","title":"Container","text":"<p>FastIoC Container module.</p> <p>Provides a dependency injection IoC container for registering and resolving dependencies with different lifetimes (singleton, request-scoped, transient) in FastAPI.</p>"},{"location":"reference/container/#fastioc.container.Container","title":"<code>Container</code>","text":"<p>Dependency Injection IoC container for registering and resolving dependencies  in FastAPI applications.</p> Supports three lifetimes <ul> <li>Singleton: One single shared instance per process/worker.</li> <li>Scoped: One instance per HTTP request, reused during that request.</li> <li>Factory: A new instance each time the dependency is resolved.</li> </ul> <p>Attributes:</p> Name Type Description <code>dependencies</code> <code>dict[type, Depends]</code> <p>Maps protocol types to FastAPI Depends instances.</p>"},{"location":"reference/container/#fastioc.container.Container.add_scoped","title":"<code>add_scoped(protocol: type, implementation: FastIoCConcrete)</code>","text":"<p>Register a request-scoped dependency.</p> <p>A new instance is created for each HTTP request and reused throughout that request.</p> <p>Parameters:</p> Name Type Description Default <code>protocol</code> <code>type</code> <p>The interface or protocol type that acts as the key for resolving this dependency.</p> required <code>implementation</code> <code>FastIoCConcrete</code> <p>The actual implementation to be provided when the protocol is resolved.</p> required <p>Raises:</p> Type Description <code>ProtocolNotRegisteredError</code> <p>If a nested dependency is not registered.</p>"},{"location":"reference/container/#fastioc.container.Container.add_singleton","title":"<code>add_singleton(protocol: type, implementation: FastIoCConcrete)</code>","text":"<p>Register a singleton dependency.</p> <p>One single shared instance will be used throughout the entire process/worker.</p> <p>Parameters:</p> Name Type Description Default <code>protocol</code> <code>type</code> <p>The interface or protocol type that acts as the key for resolving this dependency.</p> required <code>implementation</code> <code>FastIoCConcrete</code> <p>The actual implementation to be provided when the protocol is resolved.</p> required <p>Raises:</p> Type Description <code>SingletonGeneratorNotAllowedError</code> <p>If 'implementation' is a generator or async generator.</p> <code>ProtocolNotRegisteredError</code> <p>If a nested dependency is not registered.</p>"},{"location":"reference/container/#fastioc.container.Container.add_transient","title":"<code>add_transient(protocol: type, implementation: FastIoCConcrete)</code>","text":"<p>Register a transient dependency.</p> <p>A new instance is created each time the dependency is resolved.</p> <p>Parameters:</p> Name Type Description Default <code>protocol</code> <code>type</code> <p>The interface or protocol type that acts as the key for resolving this dependency.</p> required <code>implementation</code> <code>FastIoCConcrete</code> <p>The actual implementation to be provided when the protocol is resolved.</p> required <p>Raises:</p> Type Description <code>ProtocolNotRegisteredError</code> <p>If a nested dependency is not registered.</p>"},{"location":"reference/container/#fastioc.container.Container.before_register_hook","title":"<code>before_register_hook(dependency: Dependency[Any]) -&gt; Dependency[Any]</code>","text":"<p>Hook executed before a dependency is registered in the container.</p> <p>This method allows you to inspect, modify, or validate the dependency  before it is stored in the container.</p> <p>Parameters:</p> Name Type Description Default <code>dependency</code> <code>Dependency[Any]</code> <p>The dependency instance about to be registered. - <code>dependency.protocol</code>: The interface or protocol type. - <code>dependency.implementation</code>: The implementation or factory. - <code>dependency.lifetime</code>: The lifetime of the dependency (SINGLETON, SCOPED, TRANSIENT).</p> required <p>Returns:</p> Type Description <code>Dependency[Any]</code> <p>Dependency[Any]: The (optionally modified) dependency that will actually be registered.</p> Usage <p>You can override this method to implement custom logic such as: - Logging registration - Wrapping the implementation class - Validating dependency types - Applying decorators or configuration</p> <p>Example (monkey patch):</p> <pre><code>def my_register_hook(dep):\n    print(f\"Registering {dep.protocol.__name__} -&gt; {dep.implementation}\")\n    return dep\n\ncontainer = Container()\ncontainer.before_register_hook = my_register_hook  # Monkey patch the hook\n\ncontainer.add_scoped(IService, Service)\n# Now each register prints info before storing the dependency\n</code></pre>"},{"location":"reference/container/#fastioc.container.Container.before_resolve_hook","title":"<code>before_resolve_hook(dependency: Depends) -&gt; Depends</code>","text":"<p>Hook executed before a dependency is resolved from the container.</p> <p>This method allows you to inspect, wrap, or modify the dependency just before it is provided to a consumer (endpoint, service, etc).</p> <p>Parameters:</p> Name Type Description Default <code>dependency</code> <code>Depends</code> <p>The FastAPI Depends instance representing the dependency  about to be resolved. - <code>dependency.dependency</code>: The callable that will produce the actual instance. - <code>dependency.use_cache</code>: Whether the instance should be cached for reuse.</p> required <p>Returns:</p> Name Type Description <code>Depends</code> <code>Depends</code> <p>The (optionally modified) Depends instance to be used in resolution.</p> Usage <p>You can override this method to implement custom logic such as: - Logging resolution - Wrapping the callable with additional behavior - Injecting default parameters - Applying metrics or tracing</p> <p>Example (monkey patch):</p> <pre><code>def my_resolve_hook(dep):\n    print(f\"Resolving dependency {dep.dependency.__name__}\")\n    return dep\n\ncontainer = Container()\ncontainer.before_resolve_hook = my_resolve_hook  # Monkey patch the hook\n\n# Now, when resolving a dependency:\nresolved_dep = container.resolve(IService)\n# Each resolve prints info before returning the instance\n</code></pre>"},{"location":"reference/container/#fastioc.container.Container.check_if_registered","title":"<code>check_if_registered(protocol: type)</code>","text":"<p>Raises ProtocolNotRegisteredError if the protocol is not registered.</p>"},{"location":"reference/container/#fastioc.container.Container.dispose","title":"<code>dispose(app: Optional[FastAPI] = None)</code>  <code>async</code>","text":"<p>Dispose all registered singleton dependencies.</p> <p>This method calls the disposal function of each singleton that was registered in the container. Both synchronous and asynchronous disposal functions are supported. If a disposal function raises an exception, it will be caught and logged, and the disposal process will continue for the remaining singletons.</p> Logging format <p>'Error disposing \"ClassName\": exception'</p> Notes <ul> <li>Async disposal functions will be awaited.</li> <li>Errors during disposal do not prevent other singletons from being disposed.</li> </ul>"},{"location":"reference/container/#fastioc.container.Container.injectify","title":"<code>injectify(*targets: FastAPI | APIRouter)</code>","text":"<p>Wrap a FastAPI app or APIRouter to automatically inject dependencies.</p> <p>THIS MUST BE CALLED BEFORE ADDING ANY ENDPOINTS THAT REQUIRE DEPENDENCY INJECTION.</p> <p>This function overrides <code>add_api_route</code> to:     - Inject dependencies into endpoint parameters using the provided container.     - Resolve route-level dependencies automatically.     - Support both FastAPI application and APIRouter instances.</p> <p>Parameters:</p> Name Type Description Default <code>*targets</code> <code>FastAPI | APIRouter</code> <p>The FastAPI apps or APIRouters to wrap.</p> <code>()</code> <p>Examples:</p> <pre><code>app = FastAPI()\ncontainer = Container()\ncontainer.injectify(app)\n</code></pre>"},{"location":"reference/container/#fastioc.container.Container.override","title":"<code>override(dependencies: dict[Callable[..., Any], Callable[..., Any]] = {}, container: Optional[Container] = None) -&gt; dict[Callable[..., Any], Callable[..., Any]]</code>","text":"<p>Generate an updated dictionary suitable for FastAPI's <code>dependency_overrides</code>.</p> <p>This method allows merging and overriding dependencies from two sources: 1. A dictionary of user-provided overrides. 2. An optional secondary FastIoC container (e.g., a mock container for testing).</p> <p>NOTE: The lifetime of each dependency is preserved:  overridden dependencies are injected with the SAME LIFETIME AS ORIGINAL CONTAINER REGISTERATION.</p> <p>Parameters:</p> Name Type Description Default <code>dependencies</code> <code>dict[Callable[..., Any], Callable[..., Any]]</code> <p>A dictionary where keys are the original dependency callables or protocol types that may have been registered in the container, and values are the new callables that should override them.</p> <ul> <li>If a key is registered in the container, it will be replaced with the registered dependancy, while the value remains the provided override callable.</li> <li>Keys not registered in the container are left unchanged.</li> <li>This means you can mix normal FastAPI overrides with container-based dependencies without conflict.</li> </ul> <code>{}</code> <code>container</code> <code>Optional[Container]</code> <p>An optional secondary container (e.g., a test or mock container).</p> <ul> <li> <p>For each protocol in this container that is also registered in the main container, the resolved dependency from the main container will be used as the key, and the dependency from the secondary container will be used as the value.</p> </li> <li> <p>Protocols in the secondary container that are not registered in the main container are ignored.</p> </li> <li> <p>NOTE: The lifetime of each dependency should follow the main container, unless you know exactly what you are doing. </p> <ul> <li> <ul> <li>For SCOPED or FACTORY dependencies in the main container, the original lifetime is always preserved regardless of what is registered in the secondary container (except SINGLETON). </li> </ul> </li> <li> <ul> <li>For SINGLETON dependencies in the main container: if the main container has SINGLETON and the secondary container has a different lifetime, the resulting lifetime will be SCOPED; </li> </ul> </li> <li> <ul> <li>If the main container has a non-SINGLETON lifetime and the secondary container registers it as SINGLETON, the resulting lifetime will be SINGLETON.</li> </ul> </li> </ul> </li> </ul> <code>None</code> <p>Returns:</p> Type Description <code>dict[Callable[..., Any], Callable[..., Any]]</code> <p>dict[Callable[..., Any] | Depends, Callable[..., Any]]: A new dictionary suitable for assigning to <code>app.dependency_overrides</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fastioc import Container, FastAPI\n&gt;&gt;&gt; app = FastAPI()\n&gt;&gt;&gt; container = Container()\n&gt;&gt;&gt; container.add_scoped(IService, Service)\n&gt;&gt;&gt; overrides = {\n&gt;&gt;&gt;   IService: MockService,\n&gt;&gt;&gt;    some_dependency: custom_callable\n&gt;&gt;&gt; }\n&gt;&gt;&gt; app.dependency_overrides.update(container.override(overrides))\n</code></pre>"},{"location":"reference/container/#fastioc.container.Container.register","title":"<code>register(protocol: type, implementation: FastIoCConcrete, lifetime: LifeTime)</code>","text":"<p>Register a dependency with a given lifetime.</p> <p>Parameters:</p> Name Type Description Default <code>protocol</code> <code>type</code> <p>The interface or protocol type that acts as the key for resolving this dependency.</p> required <code>implementation</code> <code>FastIoCConcrete</code> <p>The actual implementation to be provided when the protocol is resolved.</p> required <code>lifetime</code> <code>Lifetime</code> <p>SINGLETON, SCOPED, or FACTORY.</p> required <p>Raises:</p> Type Description <code>SingletonGeneratorNotAllowedError</code> <p>If a generator or async generator is registered as singleton.</p>"},{"location":"reference/container/#fastioc.container.Container.resolve","title":"<code>resolve(protocol: type) -&gt; Depends</code>","text":"<p>Return the Depends instance for a protocol. Raises ProtocolNotRegisteredError if not registered.</p>"},{"location":"reference/controller/","title":"APIController","text":"<p>This module serves as the main public interface for FastIoC's controller system.</p> <p>It re-exports the core <code>APIController</code> base class and all FastIoC-compatible  route decorators (<code>get</code>, <code>post</code>, <code>put</code>, <code>patch</code>, <code>head</code>, <code>options</code>, <code>delete</code>, <code>trace</code>, <code>websocket</code>)  to provide a clean and unified import path for building dependency-injected FastAPI controllers.</p> <p>By using these exports, developers can easily define fully type-hinted, dependency-injected  controllers that integrate seamlessly with FastAPI's routing system while leveraging  FastIoC's inversion of control (IoC) container.</p>"},{"location":"reference/controller/#fastioc.controller--example","title":"Example:","text":"<pre><code>from fastioc.controller import APIController, get\nfrom my_app.interfaces import IUserService, ILoggingService\n\nclass UserController(APIController):\n    config = {\n        \"prefix\": \"/users\",\n        \"container\": app_container\n    }\n\n    logger: ILoggingService\n\n    @get(\"/\")\n    def list_users(self, service: IUserService):\n        self.logger.log('get users')\n        return service.get_all()\n\nrouter = UserController.router()\napp.include_router(router)\n</code></pre> <p>This module is intended to be the primary import surface for most applications using FastIoC's controller architecture.</p>"},{"location":"reference/controller/#fastioc.controller.APIController","title":"<code>APIController</code>","text":"<p>APIController provides an integration layer between FastIoC's dependency injection container and FastAPI's routing system.</p> <p>This class acts as a declarative controller that automatically registers all endpoint methods  decorated with FastIoC route decorators (e.g., @get, @post, etc.) into a FastIoC-powered APIRouter.</p> <p>Each route and its dependencies are resolved through FastIoC's dependency injection mechanism,  allowing constructor injection, type-hint-based injection, and lifecycle management (e.g., singleton, transient).</p> <p>The controller can define a class-level <code>config</code> attribute containing APIRouterParams, which  specifies routing configuration such as prefix, tags, responses, and more.</p> <p>\u26a0\ufe0f Important: You must include a valid <code>container</code> instance in the <code>config</code> parameter to enable dependency injection  and proper controller instantiation.</p> <p>Usage example: <pre><code>    class UserController(APIController):\n        config = {\n            \"prefix\": \"/users\",\n            \"container\": app_container\n        }\n\n        @get(\"/\")\n        def list_users(self, service: UserService):\n            return service.get_all()\n\n    router = UserController.router()\n    app.include_router(router)\n</code></pre></p>"},{"location":"reference/controller/#fastioc.controller.APIController.router","title":"<code>router(config: APIRouterParams = {}) -&gt; APIRouter</code>  <code>classmethod</code>","text":"<p>Create a new FastIoc APIRouter instance and populate it with APIRoutes.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Optional[APIRouterParams]</code> <p>Optional configuration parameters for the APIRouter.  If not provided, uses the controller's default config.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>APIRouter</code> <code>APIRouter</code> <p>An instance of fastioc.integrations.APIRouter with routes registered.</p>"},{"location":"reference/exceptions/","title":"Exceptions","text":"<p>Exceptions used by the FastIoC library.</p>"},{"location":"reference/exceptions/#fastioc.errors.FastIoCError","title":"<code>FastIoCError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base class for all exceptions raised by the FastIoC library. Allows users to catch all FastIoC-related errors with a single except clause.</p>"},{"location":"reference/exceptions/#fastioc.errors.SingletonGeneratorError","title":"<code>SingletonGeneratorError</code>","text":"<p>               Bases: <code>FastIoCError</code></p> <p>Raised when attempting to register a generator or async generator as a singleton dependency in the DI container.</p> <p>Generator objects cannot be used more than once - reusing them would raise an error. Therefore, singleton scope does not make sense here.</p>"},{"location":"reference/exceptions/#fastioc.errors.SingletonLifetimeViolationError","title":"<code>SingletonLifetimeViolationError</code>","text":"<p>               Bases: <code>FastIoCError</code></p> <p>Raised when a singleton dependency attempts to depend on a scoped or transient dependency. </p> <p>This violates lifetime rules because singleton instances live for the entire process/worker lifetime, while scoped and transient instances are created per request or per resolution. Injecting shorter-lived dependencies into a singleton may lead to captured request state, invalid references, or memory leaks.</p>"},{"location":"reference/exceptions/#fastioc.errors.UnregisteredProtocolError","title":"<code>UnregisteredProtocolError</code>","text":"<p>               Bases: <code>FastIoCError</code></p> <p>Raised when a requested protocol, interface, or service has not been registered in the container.</p>"},{"location":"reference/integrations/","title":"Integrations","text":"<p>FastIoC-Enhanced FastAPI Integration</p> <p>This module provides extended versions of FastAPI and APIRouter with automatic FastIoC dependency injection support. It allows:</p> <ul> <li>Management of global dependencies via a built-in FastIoC Container.</li> <li>Developer-friendly DX helpers for registering singleton, request-scoped, and transient dependencies.</li> <li>Seamless integration with existing FastAPI routes and APIRouters without   requiring manual injection setup.</li> </ul>"},{"location":"reference/integrations/#fastioc.integrations.APIRouter","title":"<code>APIRouter</code>","text":"<p>               Bases: <code>APIRouter</code>, <code>Injectified</code></p> <p>Extended APIRouter class with automatic FastIoC integration.</p> Features <ul> <li>Supports global dependencies via an internal FastIoC Container.   A default container is created automatically, but it can be replaced via the <code>container</code> property.</li> <li>Lazy injection of dependencies into route endpoints.</li> <li>Developer-friendly DX sugar:<ul> <li><code>add_singleton</code>, <code>add_scoped</code>, <code>add_transient</code> to register dependencies in the container.</li> </ul> </li> <li>Global and route-level dependencies are automatically processed.</li> </ul>"},{"location":"reference/integrations/#fastioc.integrations.FastAPI","title":"<code>FastAPI</code>","text":"<p>               Bases: <code>FastAPI</code>, <code>Injectified</code></p> <p>Extended FastAPI class with automatic FastIoC integration.</p> Features <ul> <li>Supports global dependencies via an internal FastIoC Container.   A default container is created automatically, but it can be replaced via the <code>container</code> property.</li> <li>Lazy injection of dependencies into route endpoints.</li> <li>Developer-friendly DX sugar:<ul> <li><code>add_singleton</code>, <code>add_scoped</code>, <code>add_transient</code> to register dependencies in the container.</li> </ul> </li> <li>Global and route-level dependencies are automatically processed.</li> </ul>"},{"location":"reference/integrations/#fastioc.integrations.Injectified","title":"<code>Injectified</code>","text":"<p>Base class providing shared FastIoC integration functionality.</p>"},{"location":"reference/integrations/#fastioc.integrations.Injectified.container","title":"<code>container: Container</code>  <code>property</code> <code>writable</code>","text":"<p>Get the FastIoC container.</p> <p>Returns:</p> Name Type Description <code>Container</code> <code>Container</code> <p>The container instance used for dependency injection.</p>"},{"location":"reference/integrations/#fastioc.integrations.Injectified.add_scoped","title":"<code>add_scoped(protocol: type, implementation: FastIoCConcrete)</code>","text":"<p>Register a request-scoped dependency into the internal container.</p> <p>A new instance is created for each HTTP request and reused throughout that request.</p> <p>Parameters:</p> Name Type Description Default <code>protocol</code> <code>type</code> <p>The interface or protocol type that acts as the key for resolving this dependency.</p> required <code>implementation</code> <code>FastIoCConcrete</code> <p>The actual implementation to be provided when the protocol is resolved.</p> required <p>Raises:</p> Type Description <code>ProtocolNotRegisteredError</code> <p>If a nested dependency is not registered.</p>"},{"location":"reference/integrations/#fastioc.integrations.Injectified.add_singleton","title":"<code>add_singleton(protocol: type, implementation: FastIoCConcrete)</code>","text":"<p>Register a singleton dependency into the internal container.</p> <p>One single shared instance will be used throughout the entire process/worker.</p> <p>Parameters:</p> Name Type Description Default <code>protocol</code> <code>type</code> <p>The interface or protocol type that acts as the key for resolving this dependency.</p> required <code>implementation</code> <code>FastIoCConcrete</code> <p>The actual implementation to be provided when the protocol is resolved.</p> required <p>Raises:</p> Type Description <code>SingletonGeneratorNotAllowedError</code> <p>If 'implementation' is a generator or async generator.</p> <code>ProtocolNotRegisteredError</code> <p>If a nested dependency is not registered.</p>"},{"location":"reference/integrations/#fastioc.integrations.Injectified.add_transient","title":"<code>add_transient(protocol: type, implementation: FastIoCConcrete)</code>","text":"<p>Register a transient dependency into the internal container.</p> <p>A new instance is created each time the dependency is resolved.</p> <p>Parameters:</p> Name Type Description Default <code>protocol</code> <code>type</code> <p>The interface or protocol type that acts as the key for resolving this dependency.</p> required <code>implementation</code> <code>FastIoCConcrete</code> <p>The actual implementation to be provided when the protocol is resolved.</p> required <p>Raises:</p> Type Description <code>ProtocolNotRegisteredError</code> <p>If a nested dependency is not registered.</p>"},{"location":"reference/integrations/#fastioc.integrations.Injectified.dispose","title":"<code>dispose()</code>  <code>async</code>","text":"<p>Dispose all registered singleton dependencies.</p> <p>This method calls the disposal function of each singleton that was registered in the container. Both synchronous and asynchronous disposal functions are supported. If a disposal function raises an exception, it will be caught and logged, and the disposal process will continue for the remaining singletons.</p> Logging format <p>'Error disposing \"ClassName\": exception'</p> Notes <ul> <li>Async disposal functions will be awaited.</li> <li>Errors during disposal do not prevent other singletons from being disposed.</li> </ul>"},{"location":"reference/integrations/#fastioc.integrations.Injectified.override_dependencies","title":"<code>override_dependencies(dependencies: dict[Callable[..., Any], Callable[..., Any]] = {}, container: Optional[Container] = None)</code>","text":"<p>Override dependencies in a FastAPI app using the integrated FastIoC container.</p> <p>This method merges user-provided overrides with the container\u2019s registered dependencies and directly updates the app\u2019s <code>dependency_overrides</code>. The original lifetime of each dependency is preserved.</p> <p>Parameters:</p> Name Type Description Default <code>dependencies</code> <code>dict[Callable[..., Any], Callable[..., Any]]</code> <p>Mapping from original dependency callables or protocol types to override callables.</p> <code>{}</code> <code>container</code> <code>Optional[Container]</code> <p>An optional secondary container (e.g., for testing or mocking). Only protocols registered in the main container are considered.</p> <code>None</code> Note <p>The lifetime of each dependency should follow the main container, unless you know exactly what you are doing.</p> <ul> <li>For SCOPED or FACTORY dependencies in the main container, the original lifetime is always preserved regardless of what is registered in the secondary container (except SINGLETON).</li> <li>For SINGLETON dependencies in the main container: if the main container has SINGLETON and the secondary container has a different lifetime, the resulting lifetime will be SCOPED;</li> <li>If the main container has a non-SINGLETON lifetime and the secondary container registers it as SINGLETON, the resulting lifetime will be SINGLETON.</li> </ul> <p>Examples:</p> <pre><code>from fastioc import FastAPI\napp = FastAPI()\napp.add_scoped(IService, Service)\noverrides = {\n    IService: MockService,\n    some_dependency: custom_callable\n}\napp.override_dependencies(overrides)\n</code></pre>"}]}