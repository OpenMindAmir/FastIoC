{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FastIoC","text":"<p>IoC/DI container for FastAPI with automatic type-based dependency injection</p> <p> </p> <p>Features:</p> <ul> <li> <p>\ud83e\uddf9 Write cleaner, loosely coupled code while staying true to the \u26d3\ufe0f\u200d\ud83d\udca5 Dependency Inversion Principle (SOLID - D) \u2014 with ABSOLUTELY ZERO boilerplate! \u26a1</p> </li> <li> <p>\u2699\ufe0f Enjoy hassle-free, automatic nested dependency resolution using Python type hints with flexible lifetimes: \u267b\ufe0f Singleton, \ud83e\uddfa Scoped, and \u2668\ufe0f Transient (inspired by .NET)</p> </li> <li> <p>\ud83d\ude80 Zero runtime overhead \u2014 everything is resolved at startup!</p> </li> <li> <p>\ud83e\udd1d 100% compatible &amp; based on FastAPI\u2019s native dependency injection \u2014 no black boxes, no magic \ud83e\ude84</p> </li> <li> <p>\u267b\ufe0f Singleton support with automatic cleanup on application shutdown \ud83e\uddf9</p> </li> <li> <p>\ud83e\uddea Full support for FastAPI's <code>dependency_overrides</code> using type annotations \u2014 even with mock containers \ud83d\udc89</p> </li> <li> <p>\ud83d\udce6 Comes with the amazing <code>APIController</code> \u2014 the best class-based view (CBV) system ever seen in Python \ud83c\udfc6</p> </li> <li> <p>\ud83d\udd04 Two operation modes: standalone \ud83c\udfd5\ufe0f and integrated \ud83e\udde9</p> </li> <li> <p>\ud83d\udd27 Comes with customizable hooks, detailed logs &amp; ... \ud83d\udcca</p> </li> </ul>"},{"location":"#installation","title":"Installation \ud83d\udce5","text":"<pre><code>$ pip install fastioc\n</code></pre>"},{"location":"#usage","title":"Usage \ud83d\udca1","text":"<p>A sample interface &amp; implementation:</p> <pre><code>from typing import Protocol\n\n# Define the interface \ud83d\udcdc\nclass IService(Protocol):\n\n    def get_number(self) -&gt; int: ...\n\n\n# Implement concrete class \ud83c\udfd7\ufe0f\nclass ExampleService(IService):\n\n    def __init__(self):\n        print(\"ExampleService created\")\n        self.number = 42\n\n    def get_number(self) -&gt; int:\n        return self.number\n</code></pre>"},{"location":"#standalone-mode-recommended","title":"Standalone Mode (Recommended) \ud83c\udfd5\ufe0f","text":"<pre><code>from fastapi import FastAPI\n\nfrom fastioc import Container # Import the Container\n\n\n# Create container and register dependency \ud83d\udcdd\ncontainer = Container()\ncontainer.add_scoped(IService, ExampleService) # Also available: add_singleton, add_transient\n\n\n# Create FastAPI app and integrate it with the container \ud83e\ude84\napp = FastAPI()\ncontainer.injectify(app)\n\n\n# Now your endpoints are injectified! \ud83c\udf89\n@app.get('/')\ndef index(service: IService) -&gt; int: # Only use the interface - no 'Depends' needed\n    return service.get_number() # 42 \ud83e\udd29\n</code></pre>"},{"location":"#integrated-mode","title":"Integrated Mode \ud83e\udde9","text":"<pre><code>from fastioc import FastAPI # Also available: APIRouter\n\napp = FastAPI()\napp.add_scoped(IService, ExampleService) # Each FastAPI/APIRouter instance maintains its own interal container (by default)\n\n# ...\n</code></pre> <p>You can read more about working with APIRouter, APIController, lifetimes, nested dependencies, singleton clean-up, overriding dependencies &amp; ... in Documentation \ud83d\udcc4</p>"},{"location":"#apicontroller","title":"APIController","text":"<pre><code>from fastapi import FastAPI\n\nfrom fastioc import Container\nfrom fastioc.controller import APIController, get, post\n\n# Create container &amp; register dependencies \ud83d\udcdd\ncontainer = Container()\ncontainer.add_scoped(IService, ExampleService)\n\n# Define an example controller\nclass ExampleController(APIController):\n    config = { # APIRouter parameters (+ IDE Autocomplete \ud83e\udd29)\n        \"prefix\": '/example',\n        \"tag\": 'example',\n        \"container\": container # ! DO NOT FORGET\n    }\n\n    service: IService # Available in all endpoints!\n\n    @get('/read')\n    def read_example(self) -&gt; int:\n        return self.service.get_number()\n\n    @post('/set')\n    def set_example(self) -&gt; bool:\n        self.service.number = 24\n        return True\n\napp = FastAPI()\napp.include_router(ExampleController.router()) # Get router from controller and include it\n</code></pre> <ul> <li>APIController endpoints are injectified so you can also resolve dependencies in each endpoint separately.</li> <li>You can also resolve dependencies in <code>__init__</code> of your controller.</li> <li>Read more in APIController</li> </ul> <p>... INCOMPLETE ...</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT License \u2014 see the LICENSE file for details.</p>"},{"location":"LICENCE/","title":"LICENCE","text":"<p>MIT License</p> <p>Copyright (c) 2025 Amir R. Aliakbari (OpenMindAmir@gmail.com)</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"reference/container/","title":"Container","text":"<p>FastIoC Container module.</p> <p>Provides a dependency injection IoC container for registering and resolving dependencies with different lifetimes (singleton, request-scoped, transient) in FastAPI.</p>"},{"location":"reference/container/#fastioc.container.Container","title":"<code>Container</code>","text":"<p>Dependency Injection IoC container for registering and resolving dependencies  in FastAPI applications.</p> Supports three lifetimes <ul> <li>Singleton: One single shared instance per process/worker.</li> <li>Scoped: One instance per HTTP request, reused during that request.</li> <li>Factory: A new instance each time the dependency is resolved.</li> </ul> <p>Attributes:</p> Name Type Description <code>dependencies</code> <code>dict[type, Depends]</code> <p>Maps protocol types to FastAPI Depends instances.</p>"},{"location":"reference/container/#fastioc.container.Container.add_scoped","title":"<code>add_scoped(protocol: type, implementation: FastIoCConcrete)</code>","text":"<p>Register a request-scoped dependency.</p> <p>A new instance is created for each HTTP request and reused throughout that request.</p> <p>Parameters:</p> Name Type Description Default <code>protocol</code> <code>type</code> <p>The interface or protocol type that acts as the key for resolving this dependency.</p> required <code>implementation</code> <code>FastIoCConcrete</code> <p>The actual implementation to be provided when the protocol is resolved.</p> required <p>Raises:</p> Type Description <code>ProtocolNotRegisteredError</code> <p>If a nested dependency is not registered.</p>"},{"location":"reference/container/#fastioc.container.Container.add_singleton","title":"<code>add_singleton(protocol: type, implementation: FastIoCConcrete)</code>","text":"<p>Register a singleton dependency.</p> <p>One single shared instance will be used throughout the entire process/worker.</p> <p>Parameters:</p> Name Type Description Default <code>protocol</code> <code>type</code> <p>The interface or protocol type that acts as the key for resolving this dependency.</p> required <code>implementation</code> <code>FastIoCConcrete</code> <p>The actual implementation to be provided when the protocol is resolved.</p> required <p>Raises:</p> Type Description <code>SingletonGeneratorNotAllowedError</code> <p>If 'implementation' is a generator or async generator.</p> <code>ProtocolNotRegisteredError</code> <p>If a nested dependency is not registered.</p>"},{"location":"reference/container/#fastioc.container.Container.add_transient","title":"<code>add_transient(protocol: type, implementation: FastIoCConcrete)</code>","text":"<p>Register a transient dependency.</p> <p>A new instance is created each time the dependency is resolved.</p> <p>Parameters:</p> Name Type Description Default <code>protocol</code> <code>type</code> <p>The interface or protocol type that acts as the key for resolving this dependency.</p> required <code>implementation</code> <code>FastIoCConcrete</code> <p>The actual implementation to be provided when the protocol is resolved.</p> required <p>Raises:</p> Type Description <code>ProtocolNotRegisteredError</code> <p>If a nested dependency is not registered.</p>"},{"location":"reference/container/#fastioc.container.Container.before_register_hook","title":"<code>before_register_hook(dependency: Dependency[Any]) -&gt; Dependency[Any]</code>","text":"<p>Hook executed before a dependency is registered in the container.</p> <p>This method allows you to inspect, modify, or validate the dependency  before it is stored in the container.</p> <p>Parameters:</p> Name Type Description Default <code>dependency</code> <code>Dependency[Any]</code> <p>The dependency instance about to be registered. - <code>dependency.protocol</code>: The interface or protocol type. - <code>dependency.implementation</code>: The implementation or factory. - <code>dependency.lifetime</code>: The lifetime of the dependency (SINGLETON, SCOPED, TRANSIENT).</p> required <p>Returns:</p> Type Description <code>Dependency[Any]</code> <p>Dependency[Any]: The (optionally modified) dependency that will actually be registered.</p> Usage <p>You can override this method to implement custom logic such as: - Logging registration - Wrapping the implementation class - Validating dependency types - Applying decorators or configuration</p> <p>Example (monkey patch):</p> <pre><code>def my_register_hook(dep):\n    print(f\"Registering {dep.protocol.__name__} -&gt; {dep.implementation}\")\n    return dep\n\ncontainer = Container()\ncontainer.before_register_hook = my_register_hook  # Monkey patch the hook\n\ncontainer.add_scoped(IService, Service)\n# Now each register prints info before storing the dependency\n</code></pre>"},{"location":"reference/container/#fastioc.container.Container.before_resolve_hook","title":"<code>before_resolve_hook(dependency: Depends) -&gt; Depends</code>","text":"<p>Hook executed before a dependency is resolved from the container.</p> <p>This method allows you to inspect, wrap, or modify the dependency just before it is provided to a consumer (endpoint, service, etc).</p> <p>Parameters:</p> Name Type Description Default <code>dependency</code> <code>Depends</code> <p>The FastAPI Depends instance representing the dependency  about to be resolved. - <code>dependency.dependency</code>: The callable that will produce the actual instance. - <code>dependency.use_cache</code>: Whether the instance should be cached for reuse.</p> required <p>Returns:</p> Name Type Description <code>Depends</code> <code>Depends</code> <p>The (optionally modified) Depends instance to be used in resolution.</p> Usage <p>You can override this method to implement custom logic such as: - Logging resolution - Wrapping the callable with additional behavior - Injecting default parameters - Applying metrics or tracing</p> <p>Example (monkey patch):</p> <pre><code>def my_resolve_hook(dep):\n    print(f\"Resolving dependency {dep.dependency.__name__}\")\n    return dep\n\ncontainer = Container()\ncontainer.before_resolve_hook = my_resolve_hook  # Monkey patch the hook\n\n# Now, when resolving a dependency:\nresolved_dep = container.resolve(IService)\n# Each resolve prints info before returning the instance\n</code></pre>"},{"location":"reference/container/#fastioc.container.Container.check_if_registered","title":"<code>check_if_registered(protocol: type)</code>","text":"<p>Raises ProtocolNotRegisteredError if the protocol is not registered.</p>"},{"location":"reference/container/#fastioc.container.Container.dispose","title":"<code>dispose(app: Optional[FastAPI] = None)</code>  <code>async</code>","text":"<p>Dispose all registered singleton dependencies.</p> <p>This method calls the disposal function of each singleton that was registered in the container. Both synchronous and asynchronous disposal functions are supported. If a disposal function raises an exception, it will be caught and logged, and the disposal process will continue for the remaining singletons.</p> Logging format <p>'Error disposing \"ClassName\": exception'</p> Notes <ul> <li>Async disposal functions will be awaited.</li> <li>Errors during disposal do not prevent other singletons from being disposed.</li> </ul>"},{"location":"reference/container/#fastioc.container.Container.injectify","title":"<code>injectify(*targets: FastAPI | APIRouter)</code>","text":"<p>Wrap a FastAPI app or APIRouter to automatically inject dependencies.</p> <p>THIS MUST BE CALLED BEFORE ADDING ANY ENDPOINTS THAT REQUIRE DEPENDENCY INJECTION.</p> <p>This function overrides <code>add_api_route</code> to:     - Inject dependencies into endpoint parameters using the provided container.     - Resolve route-level dependencies automatically.     - Support both FastAPI application and APIRouter instances.</p> <p>Parameters:</p> Name Type Description Default <code>*targets</code> <code>FastAPI | APIRouter</code> <p>The FastAPI apps or APIRouters to wrap.</p> <code>()</code> <p>Examples:</p> <pre><code>app = FastAPI()\ncontainer = Container()\ncontainer.injectify(app)\n</code></pre>"},{"location":"reference/container/#fastioc.container.Container.override","title":"<code>override(dependencies: dict[Callable[..., Any], Callable[..., Any]] = {}, container: Optional[Container] = None) -&gt; dict[Callable[..., Any], Callable[..., Any]]</code>","text":"<p>Generate an updated dictionary suitable for FastAPI's <code>dependency_overrides</code>.</p> <p>This method allows merging and overriding dependencies from two sources: 1. A dictionary of user-provided overrides. 2. An optional secondary FastIoC container (e.g., a mock container for testing).</p> <p>NOTE: The lifetime of each dependency is preserved:  overridden dependencies are injected with the SAME LIFETIME AS ORIGINAL CONTAINER REGISTERATION.</p> <p>Parameters:</p> Name Type Description Default <code>dependencies</code> <code>dict[Callable[..., Any], Callable[..., Any]]</code> <p>A dictionary where keys are the original dependency callables or protocol types that may have been registered in the container, and values are the new callables that should override them.</p> <ul> <li>If a key is registered in the container, it will be replaced with the registered dependancy, while the value remains the provided override callable.</li> <li>Keys not registered in the container are left unchanged.</li> <li>This means you can mix normal FastAPI overrides with container-based dependencies without conflict.</li> </ul> <code>{}</code> <code>container</code> <code>Optional[Container]</code> <p>An optional secondary container (e.g., a test or mock container).</p> <ul> <li> <p>For each protocol in this container that is also registered in the main container, the resolved dependency from the main container will be used as the key, and the dependency from the secondary container will be used as the value.</p> </li> <li> <p>Protocols in the secondary container that are not registered in the main container are ignored.</p> </li> <li> <p>NOTE: The lifetime of each dependency should follow the main container, unless you know exactly what you are doing. </p> <ul> <li> <ul> <li>For SCOPED or FACTORY dependencies in the main container, the original lifetime is always preserved regardless of what is registered in the secondary container (except SINGLETON). </li> </ul> </li> <li> <ul> <li>For SINGLETON dependencies in the main container: if the main container has SINGLETON and the secondary container has a different lifetime, the resulting lifetime will be SCOPED; </li> </ul> </li> <li> <ul> <li>If the main container has a non-SINGLETON lifetime and the secondary container registers it as SINGLETON, the resulting lifetime will be SINGLETON.</li> </ul> </li> </ul> </li> </ul> <code>None</code> <p>Returns:</p> Type Description <code>dict[Callable[..., Any], Callable[..., Any]]</code> <p>dict[Callable[..., Any] | Depends, Callable[..., Any]]: A new dictionary suitable for assigning to <code>app.dependency_overrides</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fastioc import Container, FastAPI\n&gt;&gt;&gt; app = FastAPI()\n&gt;&gt;&gt; container = Container()\n&gt;&gt;&gt; container.add_scoped(IService, Service)\n&gt;&gt;&gt; overrides = {\n&gt;&gt;&gt;   IService: MockService,\n&gt;&gt;&gt;    some_dependency: custom_callable\n&gt;&gt;&gt; }\n&gt;&gt;&gt; app.dependency_overrides.update(container.override(overrides))\n</code></pre>"},{"location":"reference/container/#fastioc.container.Container.register","title":"<code>register(protocol: type, implementation: FastIoCConcrete, lifetime: LifeTime)</code>","text":"<p>Register a dependency with a given lifetime.</p> <p>Parameters:</p> Name Type Description Default <code>protocol</code> <code>type</code> <p>The interface or protocol type that acts as the key for resolving this dependency.</p> required <code>implementation</code> <code>FastIoCConcrete</code> <p>The actual implementation to be provided when the protocol is resolved.</p> required <code>lifetime</code> <code>Lifetime</code> <p>SINGLETON, SCOPED, or FACTORY.</p> required <p>Raises:</p> Type Description <code>SingletonGeneratorNotAllowedError</code> <p>If a generator or async generator is registered as singleton.</p>"},{"location":"reference/container/#fastioc.container.Container.resolve","title":"<code>resolve(protocol: type) -&gt; Depends</code>","text":"<p>Return the Depends instance for a protocol. Raises ProtocolNotRegisteredError if not registered.</p>"},{"location":"reference/controller/","title":"APIController","text":"<p>This module serves as the main public interface for FastIoC's controller system.</p> <p>It re-exports the core <code>APIController</code> base class and all FastIoC-compatible  route decorators (<code>get</code>, <code>post</code>, <code>put</code>, <code>patch</code>, <code>head</code>, <code>options</code>, <code>delete</code>, <code>trace</code>, <code>websocket</code>)  to provide a clean and unified import path for building dependency-injected FastAPI controllers.</p> <p>By using these exports, developers can easily define fully type-hinted, dependency-injected  controllers that integrate seamlessly with FastAPI's routing system while leveraging  FastIoC's inversion of control (IoC) container.</p>"},{"location":"reference/controller/#fastioc.controller--example","title":"Example:","text":"<pre><code>from fastioc.controller import APIController, get\nfrom my_app.interfaces import IUserService, ILoggingService\n\nclass UserController(APIController):\n    config = {\n        \"prefix\": \"/users\",\n        \"container\": app_container\n    }\n\n    logger: ILoggingService\n\n    @get(\"/\")\n    def list_users(self, service: IUserService):\n        self.logger.log('get users')\n        return service.get_all()\n\nrouter = UserController.router()\napp.include_router(router)\n</code></pre> <p>This module is intended to be the primary import surface for most applications using FastIoC's controller architecture.</p>"},{"location":"reference/controller/#fastioc.controller.APIController","title":"<code>APIController</code>","text":"<p>APIController provides an integration layer between FastIoC's dependency injection container and FastAPI's routing system.</p> <p>This class acts as a declarative controller that automatically registers all endpoint methods  decorated with FastIoC route decorators (e.g., @get, @post, etc.) into a FastIoC-powered APIRouter.</p> <p>Each route and its dependencies are resolved through FastIoC's dependency injection mechanism,  allowing constructor injection, type-hint-based injection, and lifecycle management (e.g., singleton, transient).</p> <p>The controller can define a class-level <code>config</code> attribute containing APIRouterParams, which  specifies routing configuration such as prefix, tags, responses, and more.</p> <p>\u26a0\ufe0f Important: You must include a valid <code>container</code> instance in the <code>config</code> parameter to enable dependency injection  and proper controller instantiation.</p> <p>Usage example: <pre><code>    class UserController(APIController):\n        config = {\n            \"prefix\": \"/users\",\n            \"container\": app_container\n        }\n\n        @get(\"/\")\n        def list_users(self, service: UserService):\n            return service.get_all()\n\n    router = UserController.router()\n    app.include_router(router)\n</code></pre></p>"},{"location":"reference/controller/#fastioc.controller.APIController.router","title":"<code>router(config: Optional[APIRouterParams] = {}) -&gt; APIRouter</code>  <code>classmethod</code>","text":"<p>Create a new FastIoc APIRouter instance and populate it with APIRoutes.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Optional[APIRouterParams]</code> <p>Optional configuration parameters for the APIRouter.  If not provided, uses the controller's default config.</p> <p>NOTE: If you provide this argument, it will completely override the controller config</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>APIRouter</code> <code>APIRouter</code> <p>An instance of fastioc.integrations.APIRouter with routes registered.</p>"},{"location":"reference/exceptions/","title":"Exceptions","text":"<p>Exceptions used by the FastIoC library.</p>"},{"location":"reference/exceptions/#fastioc.errors.FastIoCError","title":"<code>FastIoCError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base class for all exceptions raised by the FastIoC library. Allows users to catch all FastIoC-related errors with a single except clause.</p>"},{"location":"reference/exceptions/#fastioc.errors.SingletonGeneratorError","title":"<code>SingletonGeneratorError</code>","text":"<p>               Bases: <code>FastIoCError</code></p> <p>Raised when attempting to register a generator or async generator as a singleton dependency in the DI container.</p> <p>Generator objects cannot be used more than once - reusing them would raise an error. Therefore, singleton scope does not make sense here.</p>"},{"location":"reference/exceptions/#fastioc.errors.SingletonLifetimeViolationError","title":"<code>SingletonLifetimeViolationError</code>","text":"<p>               Bases: <code>FastIoCError</code></p> <p>Raised when a singleton dependency attempts to depend on a scoped or transient dependency. </p> <p>This violates lifetime rules because singleton instances live for the entire process/worker lifetime, while scoped and transient instances are created per request or per resolution. Injecting shorter-lived dependencies into a singleton may lead to captured request state, invalid references, or memory leaks.</p>"},{"location":"reference/exceptions/#fastioc.errors.UnregisteredProtocolError","title":"<code>UnregisteredProtocolError</code>","text":"<p>               Bases: <code>FastIoCError</code></p> <p>Raised when a requested protocol, interface, or service has not been registered in the container.</p>"},{"location":"reference/integrations/","title":"Integrations","text":"<p>FastIoC-Enhanced FastAPI Integration</p> <p>This module provides extended versions of FastAPI and APIRouter with automatic FastIoC dependency injection support. It allows:</p> <ul> <li>Management of global dependencies via a built-in FastIoC Container.</li> <li>Developer-friendly DX helpers for registering singleton, request-scoped, and transient dependencies.</li> <li>Seamless integration with existing FastAPI routes and APIRouters without   requiring manual injection setup.</li> </ul>"},{"location":"reference/integrations/#fastioc.integrations.APIRouter","title":"<code>APIRouter</code>","text":"<p>               Bases: <code>APIRouter</code>, <code>Injectified</code></p> <p>Extended APIRouter class with automatic FastIoC integration.</p> Features <ul> <li>Supports global dependencies via an internal FastIoC Container.   A default container is created automatically, but it can be replaced via the <code>container</code> property.</li> <li>Lazy injection of dependencies into route endpoints.</li> <li>Developer-friendly DX sugar:<ul> <li><code>add_singleton</code>, <code>add_scoped</code>, <code>add_transient</code> to register dependencies in the container.</li> </ul> </li> <li>Global and route-level dependencies are automatically processed.</li> </ul>"},{"location":"reference/integrations/#fastioc.integrations.FastAPI","title":"<code>FastAPI</code>","text":"<p>               Bases: <code>FastAPI</code>, <code>Injectified</code></p> <p>Extended FastAPI class with automatic FastIoC integration.</p> Features <ul> <li>Supports global dependencies via an internal FastIoC Container.   A default container is created automatically, but it can be replaced via the <code>container</code> property.</li> <li>Lazy injection of dependencies into route endpoints.</li> <li>Developer-friendly DX sugar:<ul> <li><code>add_singleton</code>, <code>add_scoped</code>, <code>add_transient</code> to register dependencies in the container.</li> </ul> </li> <li>Global and route-level dependencies are automatically processed.</li> </ul>"},{"location":"reference/integrations/#fastioc.integrations.Injectified","title":"<code>Injectified</code>","text":"<p>Base class providing shared FastIoC integration functionality.</p>"},{"location":"reference/integrations/#fastioc.integrations.Injectified.container","title":"<code>container: Container</code>  <code>property</code> <code>writable</code>","text":"<p>Get the FastIoC container.</p> <p>Returns:</p> Name Type Description <code>Container</code> <code>Container</code> <p>The container instance used for dependency injection.</p>"},{"location":"reference/integrations/#fastioc.integrations.Injectified.add_scoped","title":"<code>add_scoped(protocol: type, implementation: FastIoCConcrete)</code>","text":"<p>Register a request-scoped dependency into the internal container.</p> <p>A new instance is created for each HTTP request and reused throughout that request.</p> <p>Parameters:</p> Name Type Description Default <code>protocol</code> <code>type</code> <p>The interface or protocol type that acts as the key for resolving this dependency.</p> required <code>implementation</code> <code>FastIoCConcrete</code> <p>The actual implementation to be provided when the protocol is resolved.</p> required <p>Raises:</p> Type Description <code>ProtocolNotRegisteredError</code> <p>If a nested dependency is not registered.</p>"},{"location":"reference/integrations/#fastioc.integrations.Injectified.add_singleton","title":"<code>add_singleton(protocol: type, implementation: FastIoCConcrete)</code>","text":"<p>Register a singleton dependency into the internal container.</p> <p>One single shared instance will be used throughout the entire process/worker.</p> <p>Parameters:</p> Name Type Description Default <code>protocol</code> <code>type</code> <p>The interface or protocol type that acts as the key for resolving this dependency.</p> required <code>implementation</code> <code>FastIoCConcrete</code> <p>The actual implementation to be provided when the protocol is resolved.</p> required <p>Raises:</p> Type Description <code>SingletonGeneratorNotAllowedError</code> <p>If 'implementation' is a generator or async generator.</p> <code>ProtocolNotRegisteredError</code> <p>If a nested dependency is not registered.</p>"},{"location":"reference/integrations/#fastioc.integrations.Injectified.add_transient","title":"<code>add_transient(protocol: type, implementation: FastIoCConcrete)</code>","text":"<p>Register a transient dependency into the internal container.</p> <p>A new instance is created each time the dependency is resolved.</p> <p>Parameters:</p> Name Type Description Default <code>protocol</code> <code>type</code> <p>The interface or protocol type that acts as the key for resolving this dependency.</p> required <code>implementation</code> <code>FastIoCConcrete</code> <p>The actual implementation to be provided when the protocol is resolved.</p> required <p>Raises:</p> Type Description <code>ProtocolNotRegisteredError</code> <p>If a nested dependency is not registered.</p>"},{"location":"reference/integrations/#fastioc.integrations.Injectified.dispose","title":"<code>dispose()</code>  <code>async</code>","text":"<p>Dispose all registered singleton dependencies.</p> <p>This method calls the disposal function of each singleton that was registered in the container. Both synchronous and asynchronous disposal functions are supported. If a disposal function raises an exception, it will be caught and logged, and the disposal process will continue for the remaining singletons.</p> Logging format <p>'Error disposing \"ClassName\": exception'</p> Notes <ul> <li>Async disposal functions will be awaited.</li> <li>Errors during disposal do not prevent other singletons from being disposed.</li> </ul>"},{"location":"reference/integrations/#fastioc.integrations.Injectified.override_dependencies","title":"<code>override_dependencies(dependencies: dict[Callable[..., Any], Callable[..., Any]] = {}, container: Optional[Container] = None)</code>","text":"<p>Override dependencies in a FastAPI app using the integrated FastIoC container.</p> <p>This method merges user-provided overrides with the container\u2019s registered dependencies and directly updates the app\u2019s <code>dependency_overrides</code>. The original lifetime of each dependency is preserved.</p> <p>Parameters:</p> Name Type Description Default <code>dependencies</code> <code>dict[Callable[..., Any], Callable[..., Any]]</code> <p>Mapping from original dependency callables or protocol types to override callables.</p> <code>{}</code> <code>container</code> <code>Optional[Container]</code> <p>An optional secondary container (e.g., for testing or mocking). Only protocols registered in the main container are considered.</p> <code>None</code> Note <p>The lifetime of each dependency should follow the main container, unless you know exactly what you are doing.</p> <ul> <li>For SCOPED or FACTORY dependencies in the main container, the original lifetime is always preserved regardless of what is registered in the secondary container (except SINGLETON).</li> <li>For SINGLETON dependencies in the main container: if the main container has SINGLETON and the secondary container has a different lifetime, the resulting lifetime will be SCOPED;</li> <li>If the main container has a non-SINGLETON lifetime and the secondary container registers it as SINGLETON, the resulting lifetime will be SINGLETON.</li> </ul> <p>Examples:</p> <pre><code>from fastioc import FastAPI\napp = FastAPI()\napp.add_scoped(IService, Service)\noverrides = {\n    IService: MockService,\n    some_dependency: custom_callable\n}\napp.override_dependencies(overrides)\n</code></pre>"}]}